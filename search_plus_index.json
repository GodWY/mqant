{"./":{"url":"./","title":"Introduction","keywords":"","body":"内容简介其中入门篇（第1章~第5章）进阶篇（第6章~第8章）实战篇（第9章~以后）示例源码mqant版本内容简介 本教程由浅入深的介绍了mqant技术架构和开发流程。本教程不仅包含大量示例、图片，还有配套的示例源码， 可帮助读者循序渐进的掌握mqant开发技术。本书分为入门、进阶两大篇. 其中入门篇（第1章~第5章） 主要介绍了mqant技术产生的背景、框架、服务发现、部署，通过入门篇的学习，读者可以掌握如何使用mqant来构建微服务应用。 进阶篇（第6章~第8章） 包括mqant中的RPC高级用法、长连接网关、HTTP网关等。通过本章内容，读者可以对mqant整体构建及原理有一个深入的认识。 实战篇（第9章~以后） 按业务场景讲解一些实战案例，通用库等 示例源码 教程中所使用的示例源码都已上传github mqant-example mqant版本 ^v1.3.94 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-11-12 19:43:06 "},"Introduction.html":{"url":"Introduction.html","title":"前言","keywords":"","body":"前言缘起为什么决定要重新造一个轮子?首先是开发语言c/c++.netpythonjavajavascript开源框架:golang游戏框架的不足mqant框架的架构演进阶段一（配置路由模式）阶段二（自动服务注册与发现）未来前言 本教程是第一本系统介绍mqant技术的中文教程，旨在帮助开发者入门，系统地、循序渐进的了解mqant微服务框架。 缘起 2016年底的时候对即时通讯以及游戏开发产生了一些兴趣,而且自己这方面的知识掌握也非常少, 在未来很多产品应该都会使用到长连接技术(物联网IOT),因此很有必要掌握这方面的技术。 于是就在网络上查询相关的资料,但发现目前网络上的开源游戏服务器框架相对较少, 而目前市面上已有的一些开源游戏框架又不太对自己的胃口。 就抽时间按照自己对游戏服务器的架构思路做了一套,取名就叫mqant。 为什么决定要重新造一个轮子? 目前网上优秀的开源游戏服务器框架也不少(当然与web框架比起来就少太多了),但总结起来都各有各的优缺点,下面列出我在选型过程中的一些考量,希望大家能开放的讨论,有不恰当的地方也请指正。 首先是开发语言 目前用于游戏服务器开发的主要应该有以下这些语言: c/c++ 优点: 性能很好 缺点: 不过我个人不会C++ 开源框架: skynet 底层是C 开发语言是lua, 没有客户端库 kbengine 底层是C++ 开发语言可以使用C#,Python 有多个平台的客户端库 .net 优点: 性能很好 缺点: 不过我个人不会C# 开源框架: Scut 底层C# 开发语言是 C#、Python和Lua多种脚本进行开发 有多个平台的客户端库 Photon 底层C# 好像是收费的,但毕竟出名 有多个平台的客户端库 python 是我最想使用的一种开发语言 开发效率非常高 支持协程,能开发出高并发性的游戏,而且代码可读性好 目前有很多游戏公司应该都使用的是Python作为后端游戏服务器开发语言,有相对成熟的案例 缺点: Python很致命的一个问题是进程不能利用多核,也就是说一个进程只能利用一个CPU进行计算,如果要用多核就需要新开进程,这样会造成服务器的维护成本增加,而且开发项目时所需要考虑的问题也更多 开源框架: twisted 可以用来做网关服务器 firefly 应该很早就不维护了 java 没有找到比较好的开源框架 对协程支持不够好 开发效率较低 javascript 优点: 语法灵活(这是一把双刃刀,用起来要小心,尤其是团队开发中) 开源库丰富 缺点: 语法上有一些缺陷 跟Python一样不支持多核 对协程支持不够好,地狱回调很可怕,虽然有一些解决方案,但用起来稍微有点别扭 开源框架: Pomelo 网易出品,不怎么维护了 有多个平台的客户端库 golang 优点: 性能好,跟C/C++/C#一样编译型语言 语法比较简单,开发效率也比较高,接近Python 语言级别支持协程 单进程支持多核并发计算 缺点: 开源库较少,会golang的开发者比较少 开源框架: leaf 接触的第一个golang框架,设计不错,但不支持多进程没有客户端库,需要自己实现 cellnet 刚接触,没法评价,但好像它用了callback回调函数的设计,这样的设计在golang应该可以避免 游戏框架的不足 结合个人的实际情况,当时我主要的选择从 skynet Pomelo leaf 这三个框架里面来选择 skynet设计思路非常牛逼,看了风云大牛的设计感觉应该是一个高性能,高稳定性的游戏服务器框架,而且有很多产品已经使用上了。 但个人认为skynet可能也会有以下的两个问题 Actor模式可能对架构能力比较高,不如rpc模式明了 skynet使用第三方网络库的时候可能需要造轮子,要放开膀子开发有些难,跟python tornado的一样,要写出高性能的程序也对开发人员有一定的要求 Pomelo由网易团队开发的,对多进程架构做的非常好,不过由于javascript性能的关系Pomelo的定位也在一些中小型非即时战斗类游戏,经过一段时间的学习和测试,最后还是无奈放弃了 最后经过多方考虑,我选择golang作为开发语言,当时第一个接触的就是leaf,学习开发了一段时间发现了leaf的一些不足 不支持多进程 没有客户端开发库,需要自己造轮子 上面列出来的都是这几个框架的缺点,其实这几个框架都非常优秀,只是不同的需求有不同的要求罢了,希望大家能根据自己实际需求选择最适合自己的框架 对游戏服务器框架的想法 自己心里也对游戏服务器框架有一些自己的想法,最终决定造这个轮子。 高性能,支持多核 这在未来开发,扩展,维护会轻松很多,比如Python这样一台服务器跑上百个进程的游戏服务器,维护起来就很让人头疼 支持协程 协程在客户端中应用不大,但在服务器开发中可以发挥极大的威力: 高并发,能最大的利用cpu资源 异步开发同步化,免去了回调函数设计,避免了地狱回调 支持分布式,但也支持单进程部署 有些框架写一个demo都需要启动多个进程,实际上在项目前期可能一台服务器就能够支持了,我希望实现一个既可以单进程部署又可以分布式部署的框架 单进程能够实现高性能 分布式部署不用重新设计编码 这个需求的实现主要靠约定,只要开发的时候按分布式环境来开发,代码一般都不需要移植 有丰富的客户端开发库 让开发者专心业务开发,不同再去造轮子了 mqant框架的架构 mqant就是按照以上的思路设计的,同时设计思路上参考了Pomelo,并且也使用了leaf框架的部分代码。 golang本身支持高性能,支持多核 支持协程 支持分布式,但也支持单进程部署 mqant是按模块为单位来划分功能模块的,可以将一组模块放到一个进程来运行,也可以将所有模块放到同一个进程来运行(即单进程模式) mqant模块间约定按标准的RPC来相互调用 有丰富的客户端开发库 mqant没有考虑帮开发者造一个客户端开发库,而是选用了目前物联网中非常流行mqtt协议来作为通信协议, mqtt本身就有各个平台的客户端开发库,因此可以直接用mqtt的客户端开发库对接到mqant上来。 实现了mqant跨平台通信的要求。 当然开发者依然可以在mqant框架中自定义自己开发通信协议。 演进 mqant到目前进行了两个阶段的演进 阶段一（配置路由模式） 在mqant刚发布时,并没有服务注册和发现功能,虽然支持分布式RPC通信但是通信节点配置都需要提前在配置文件中写明。 阶段二（自动服务注册与发现） mqant吸收了go-mirco框架的架构以后，加入了服务注册与发现功能，实现服务自动发现与注销,无需提前配置。同时对RPC的选项也进行了改动 从原有的redis、rabbitmq改为了nats，降低了系统复杂度。 未来 未来mqant会专注在核心功能优化,丰富实际应用场景上。在游戏,iot,im等更多场景中探索,沉淀通用组件和方案。 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-02 10:23:45 "},"Community.html":{"url":"Community.html","title":"社区","keywords":"","body":"社区社区 mqant交流群2（请加此群）：1154240699 QQ交流群（已满） :463735103 技术交流社区:www.mqant.com Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-11-12 19:40:22 "},"tool.html":{"url":"tool.html","title":"介绍","keywords":"","body":"介绍mqant核心组件组成名称定义介绍 mqant是一个微服务框架。目标是简化分布式系统开发。 mqant的核心是简单易用,关注业务场景,因此会针对特定场景研究一些特定组件和解决方案,方便开发者使用。 mqant核心组件组成 核心RPC组件 - 它提供了用于服务发现，客户端负载平衡，编码，同步通信库。 http网关 - 提供将HTTP请求路由到相应微服务的API网关。它充当单个入口点，可以用作反向代理或将HTTP请求转换为RPC。 tcp/websocket网关 - 它提供了tcp和websocket两种客户端连接方式。并且默认内置了一个简单的mqtt协议，可以非常便捷的 提供长连接服务,快速搭建iot和网络游戏通信业务，同时也支持自定义通信协议插件。 名称定义 模块 一类功能的统称,在mqant中以模块划分代码结构。 服务 服务即模块,在微服务中服务比模块更容易让人理解。 节点 即模块(服务)部署后的实例，一个模块(服务)可以在多台服务器启动多个节点。 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 11:06:32 "},"framework.html":{"url":"framework.html","title":"架构","keywords":"","body":"处理器(handler)模块间通信RPC为什么选择消息队列进行RPC通信?现如今只有多进程的架构才能达到支撑较多在线用户,降低服务器压力,降低单点故障所带来的影响等要求,因此一个真正高可扩展的游戏运行架构必须是多进程的。 然而在游戏的开发和运营也是按步骤阶段性进行的,尤其是现如今服务器硬件设备配置也越来越高的前提下,在游戏刚开始运营时单台服务器就足够支撑了,况且多进程部署所带来的运维成本也相对较高。 mqant的设计思想是在能用单台服务器时能让充分挖掘服务器的性能,而在需要多进程时再通过简单的配置就可以实现分布式部署。 mqant框架架构图 mqant模块化运行架构图 处理器(handler) handler就是一个可供远程RPC调用的函数 每一个模块可以注册多个处理器(handler),例如用户模块可以提供用户注册、用户登录、用户注销、用户信息查询等一系列的处理器 模块间通信RPC mqant模块间的通信方式应该使用RPC,而非本地代码调用。 mqant的RPC也非采取grpc等消息投递工具，而是选用了nats消息总线。 为什么选择消息队列进行RPC通信? 选择消息队列而不选择传统的tcp/socket rpc的主要考虑是传统的基于点对点service/client模式的连接比较难于维护和统计,假如服务器存在100个模块和服务器的话进一个进程所需要维护的client连接就>100个(计算可能不太准确(^—^)). 而选择消息队列的话每一个进程对每一个模块只需要维护一条连接即可,nats有完善的监控,报警工具,可以随时监控模块的处理性能和实时性。 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-02 11:48:20 "},"docker.html":{"url":"docker.html","title":"docker","keywords":"","body":"概述快速部署docker版本服务端使用dockerfile编译镜像概述 镜像中包含了golang编译环境和mqant所必须的中间件 consul nats 前提条件是已安装docker环境 快速部署docker版本服务端 下载镜像 docker pull 1587790525/mqant-example:latest 启动镜像 docker run -p 3563:3563 -p 3653:3653 -p 8080:8080 1587790525/mqant-example 访问服务接口 http://127.0.0.1:8080/say?name=mqant 验证golang客户端 运行 robot/robot_task.go 使用dockerfile编译镜像 克隆git工程 git clone https://github.com/liangdas/mqant-example 制作docker镜像 首先进入工程目录下 docker build -t Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-17 12:37:27 "},"install_mqant.html":{"url":"install_mqant.html","title":"搭建","keywords":"","body":"安装mqant依赖代码组织结构入口运行配置运行安装mqant 以下教程已默认您已具备了golang语言开发的基础知识,了解gomod运作模式 依赖 go 1.13 require github.com/liangdas/mqant v1.4.5 代码组织结构 工程目录 |-bin |-conf |-server.json |-main.go 入口 main.go import ( \"github.com/liangdas/mqant\" \"github.com/liangdas/mqant/module\" ) func main() { app := mqant.CreateApp( module.Debug(true),//只有是在调试模式下才会在控制台打印日志, 非调试模式下只在日志文件中输出日志 ) app.Run( //已实现的模块都应该在此处传入 ) } 运行 如果此时直接运行会报错(没有指定配置文件) panic: config path error open xxx/bin/conf/server.json: no such file or directory 配置 先按目录创建一个配置文件模板，后续教程会单独章节介绍配置文件的格式和用法 server.json { \"Module\":{ }, \"Mqtt\":{ \"WirteLoopChanNum\": 10, \"ReadPackLoop\": 1, \"ReadTimeout\": 600, \"WriteTimeout\": 300 }, \"Rpc\":{ \"MaxCoroutine\":10000, \"RpcExpired\": 1, \"LogSuccess\":false } } 运行 2020-05-03T18:00:55.033228+08:00 [-] [-] [] [E] nats agent: nats: no servers available for connection Server configuration path : //work/go/mqant-helloworld/bin/conf/server.json 2020-05-03T18:00:55.034615+08:00 [-] [-] [development] [I] [app.go:203] mqant starting up 2020-05-03T18:00:55.034707+08:00 [-] [-] [development] [I] [ModuleManager.go:50] This service ModuleGroup(ProcessID) is [development] 可以看到框架已经运行起来了，但是什么都没有，仅仅运行了一个脚手架而已 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-17 12:31:04 "},"app_introduce.html":{"url":"app_introduce.html","title":"应用","keywords":"","body":"模块应用生命周期配置解析完成应用启动完成设置强杀时间模块 应用(app)是mqant的最基本单位，通常一个进程中只需要实例化一个应用(app). 应用负责维护整个框架的基本服务 服务注册与发现 RPC通信 模块依赖 应用生命周期 配置解析完成 _ = app.OnConfigurationLoaded(func(app module.App) { } 应用启动完成 包括模块启动完成 app.OnStartup(func(app module.App){ }) 设置强杀时间 当出现模块卡死等无法退出进程情况下,超过设置时间会强杀 app := mqant.CreateApp( module.KillWaitTTL(1*time.Minute), ) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-07 09:45:10 "},"module_introduce.html":{"url":"module_introduce.html","title":"模块","keywords":"","body":"脚手架模块模块定义模块生命周期模块使用不在进程分组中的模块如何初始化？脚手架 mqant以模块化来组织代码模块,模块概念在框架中非常重要,以下教程将详细讲解模块的生命周期和用法 模块 模块定义 结构体只要实现了以上几个函数就被认为是一个模块 //指定一个模块的名称,非常重要,在配置文件和RPC路由中会频繁使用 func GetType() string //指定模块的版本 func Version() string //模块的初始化函数,当框架初始化模块是会主动调用该方法 func OnInit(app module.App, settings *conf.ModuleSettings) //当App解析配置后调用，这个接口不管这个模块是否在这个进程的模块分组中都会调用 func OnAppConfigurationLoaded(app module.App) //模块独立运行函数,框架初始化模块以后会以单独goroutine运行该函数,并且提供一个关闭信号,以再框架要停止模块时通知 func Run(closeSig chan bool) //当模块停止运行后框架会调用该方法,让模块做一些回收操作 func OnDestroy() 模块生命周期 模块使用 通常我们不止是实现一个简单模块，还需要利用框架的其他高级特性，因此我们通常会继承框架封装好的一些基础模块 RPCModule 继承 basemodule.BaseModule该模块封装了mqant的RPC通信相关方法 GateModule 继承 basegate.Gate该模块封装了tcp/websocket+mqtt协议的长连接网关 不在进程分组中的模块如何初始化？ func (self *HellWorld) OnAppConfigurationLoaded(app module.App) { //当App初始化时调用，这个接口不管这个模块是否在这个进程运行都会调用 self.BaseModule.OnAppConfigurationLoaded(app) } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 18:12:53 "},"first_module.html":{"url":"first_module.html","title":"编写第一个模块","keywords":"","body":"代码组织结构编写第一个模块尝试运行运行停止代码组织结构 首先我们重新组织了一下代码目录结构，新增了一个helloworld目录用来存放模块代码 工程目录 |-bin |-conf |-server.conf |-helloworld |-module.go |-xxx.go |-main.go 编写第一个模块 package helloworld import ( \"github.com/liangdas/mqant/conf\" \"github.com/liangdas/mqant/log\" \"github.com/liangdas/mqant/module\" \"github.com/liangdas/mqant/module/base\" ) var Module = func() module.Module { this := new(HellWorld) return this } type HellWorld struct { basemodule.BaseModule } func (self *HellWorld) GetType() string { //很关键,需要与配置文件中的Module配置对应 return \"helloworld\" } func (self *HellWorld) Version() string { //可以在监控时了解代码版本 return \"1.0.0\" } func (self *HellWorld) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings) log.Info(\"%v模块初始化完成...\",self.GetType()) } func (self *HellWorld) Run(closeSig chan bool) { log.Info(\"%v模块运行中...\",self.GetType()) log.Info(\"%v say hello world...\",self.GetType()) 尝试运行 2020-05-03T18:27:19.224684+08:00 [-] [-] [] [E] nats agent: nats: no servers available for connection Server configuration path : //work/go/mqant-helloworld/bin/conf/server.json 2020-05-03T18:27:19.225643+08:00 [-] [-] [development] [I] [app.go:203] mqant starting up 2020-05-03T18:27:19.225725+08:00 [-] [-] [development] [I] [ModuleManager.go:50] This service ModuleGroup(ProcessID) is [development] 运行以后没有看到我们关注的模块日志。原因是还有两项工作我们没有完成 将模块加入main.go入口函数 func main() { go func() { http.ListenAndServe(\"0.0.0.0:6060\", nil) }() app := mqant.CreateApp( module.Debug(true),//只有是在调试模式下才会在控制台打印日志, 非调试模式下只在日志文件中输出日志 ) err:= app.Run( helloworld.Module(), ) if err!=nil{ log.Error(err.Error()) } } 在配置文件中加入模块配置 { \"Module\":{ \"helloworld\":[ { \"Id\":\"helloworld\", \"ProcessID\":\"development\" } ] }, 。。。 } 配置说明 Module |-moduleType 与func GetType() string 值保持一致 |- ProcessID 模块分组,在今后分布式部署时非常有用，默认分组为development 运行 2020-05-03T18:42:09.465739+08:00 [-] [-] [] [E] nats agent: nats: no servers available for connection Server configuration path : //work/go/mqant-helloworld/bin/conf/server.json 2020-05-03T18:42:09.466789+08:00 [-] [-] [development] [I] [app.go:203] mqant starting up 2020-05-03T18:42:09.466889+08:00 [-] [-] [development] [I] [ModuleManager.go:50] This service ModuleGroup(ProcessID) is [development] 2020-05-03T18:42:09.467058+08:00 [-] [-] [development] [I] [rpc_server.go:142] Registering node: HelloWorld@1b0073cbbab33247 2020-05-03T18:42:09.468696+08:00 [-] [-] [development] [I] [module.go:32] HelloWorld模块初始化完成... 2020-05-03T18:42:09.468907+08:00 [-] [-] [development] [I] [module.go:36] HelloWorld模块运行中... 2020-05-03T18:42:09.468984+08:00 [-] [-] [development] [I] [module.go:37] HelloWorld say hello world... 2020-05-03T18:42:09.468725+08:00 [-] [-] [development] [I] [rpc_server.go:142] Registering node: HelloWorld@1b0073cbbab33247 停止 追加日志 2020-05-03T18:42:31.347133+08:00 [-] [-] [development] [I] [module.go:39] HelloWorld模块已停止... 2020-05-03T18:42:31.347248+08:00 [-] [-] [development] [I] [module.go:45] HelloWorld模块已回收... 2020-05-03T18:42:31.34735+08:00 [-] [-] [development] [I] [app.go:238] mqant closing down (signal: interrupt) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-27 19:24:18 "},"first_handler.html":{"url":"first_handler.html","title":"编写第一个handler","keywords":"","body":"介绍代码组织结构依赖服务发现启动consulRPC调用启动natsmqant加入consul和nats编写第一个handler创建一个web模块特性注意事项运行通过浏览器访问访问结果介绍 上一章节我们实现了一个helloworld模块，但模块并没有真正的功能，仅仅进行生命周期的日志输出。 实际上真正的模块应该有自身功能的核心实现 作为一个网关模块 作为一个后端模块提供核心功能的handler给其他模块使用 下面就介绍一个后端模块如何实现一个handler并且能被其他模块调用的 代码组织结构 首先我们重新组织了一下代码目录结构，新增了一个web目录用来存放http网关模块代码 工程目录 |-bin |-conf |-server.conf |-helloworld |-module.go |-web |-module.go |-main.go 依赖 服务发现 我们需要服务发现，所以让我们启动Consul（默认），或者通过go-plugins替换。 不用意外mqant的服务发现模块是从go-mirco移植而来的，因此基本可以完全复用go-mirco服务发现相关插件和功能 consul官方安装文档 启动consul 本地执行命令 consul agent --dev RPC调用 我们需要nats作为我们RPC的消息投递通道，mqant默认只内置了nats一种通道 nats官方安装文档 启动nats 本地执行命令 gnatsd bash-3.2$ gnatsd [21101] 2020/05/03 19:18:06.041187 [INF] Starting nats-server version 2.0.0-RC2 [21101] 2020/05/03 19:18:06.041356 [INF] Git commit [not set] [21101] 2020/05/03 19:18:06.042136 [INF] Listening for client connections on 0.0.0.0:4222 [21101] 2020/05/03 19:18:06.042148 [INF] Server id is NBJOWGQUQF44WTUDZJTUM6BPQWTPIFXXTBGYH3AZBP7U53TQP5PHCFHM [21101] 2020/05/03 19:18:06.042153 [INF] Server is ready mqant加入consul和nats consul和nats本身配置项较多,因此不能通过mqant的配置设置 import ( \"github.com/liangdas/mqant\" \"github.com/liangdas/mqant/log\" \"github.com/liangdas/mqant/module\" \"github.com/liangdas/mqant/registry\" \"github.com/liangdas/mqant/registry/consul\" \"github.com/nats-io/nats.go\" \"mqant-helloworld/helloworld\" ) func main() { rs := consul.NewRegistry(func(options *registry.Options) { options.Addrs = []string{\"127.0.0.1:8500\"} }) nc, err := nats.Connect(\"nats://127.0.0.1:4222\", nats.MaxReconnects(10000)) if err != nil { log.Error(\"nats error %v\", err) return } app := mqant.CreateApp( module.Debug(true),//只有是在调试模式下才会在控制台打印日志, 非调试模式下只在日志文件中输出日志 module.Nats(nc), //指定nats rpc module.Registry(rs), //指定服务发现 ) err= app.Run( //模块都需要加到入口列表中传入框架 helloworld.Module(), ) if err!=nil{ log.Error(err.Error()) } } 编写第一个handler package helloworld import ( \"fmt\" \"github.com/liangdas/mqant/conf\" \"github.com/liangdas/mqant/log\" \"github.com/liangdas/mqant/module\" \"github.com/liangdas/mqant/module/base\" ) var Module = func() module.Module { this := new(HellWorld) return this } type HellWorld struct { basemodule.BaseModule } func (self *HellWorld) GetType() string { //很关键,需要与配置文件中的Module配置对应 return \"helloworld\" } func (self *HellWorld) Version() string { //可以在监控时了解代码版本 return \"1.0.0\" } func (self *HellWorld) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings) self.GetServer().RegisterGO(\"/say/hi\", self.say) //handler log.Info(\"%v模块初始化完成...\",self.GetType()) } func (self *HellWorld) Run(closeSig chan bool) { log.Info(\"%v模块运行中...\",self.GetType()) log.Info(\"%v say hello world...\",self.GetType()) 新增handler函数 name 为传入值 r 为函数正常处理err情况下的返回内容 err 为函数异常处理情况下的返回内容 func say(name string) (r string,err error) 将handler注册到模块中 /say/hi 为访问地址 self.GetServer().RegisterGO(\"/say/hi\", self.say) 创建一个web模块 在helloworld模块中实现了第一个handler，但是没有地方在使用它，因此我们编写一个web模块尝试通过http能调用这个handler package web import ( \"context\" \"github.com/liangdas/mqant/conf\" \"github.com/liangdas/mqant/log\" \"github.com/liangdas/mqant/module\" \"github.com/liangdas/mqant/module/base\" \"github.com/liangdas/mqant/rpc\" \"io\" \"net/http\" ) var Module = func() module.Module { this := new(Web) return this } type Web struct { basemodule.BaseModule } func (self *Web) GetType() string { //很关键,需要与配置文件中的Module配置对应 return \"Web\" } func (self *Web) Version() string { //可以在监控时了解代码版本 return \"1.0.0\" } func (self *Web) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings) } func (self *Web)startHttpServer() *http.Server { srv := &http.Server{Addr: \":8080\"} http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { _ = r.ParseForm() rstr,err:=mqrpc.String( self.Call( context.Background(), \"helloworld\", \"/say/hi\", mqrpc.Param(r.Form.Get(\"name\")), ), ) log.Info(\"RpcCall %v , err %v\",rstr,err) _, _ = io.WriteString(w, rstr) }) go func() { if err := srv.ListenAndServe(); err != nil { // cannot panic, because this probably is an intentional close log.Info(\"Httpserver: ListenAndServe() error: %s\", err) } }() // returning reference so caller can call Shutdown() return srv } func (self *Web) Run(closeSig chan bool) { log.Info(\"web: starting HTTP server :8080\") srv := self.startHttpServer() 特性 web模块对外监听8080端口 http://127.0.0.1:8080/say?name=mqant web模块收到请求后,通过RPC调用helloworld模块提供的hander,并将结果返回客户端 http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { _ = r.ParseForm() rstr,err:=mqrpc.String( self.Call( context.Background(), \"helloworld\", \"/say/hi\", mqrpc.Param(r.Form.Get(\"name\")), ), ) log.Info(\"RpcCall %v , err %v\",rstr,err) _, _ = io.WriteString(w, rstr) }) 注意事项 web模块需要加入main.go 函数入口中 err= app.Run( //模块都需要加到入口列表中传入框架 helloworld.Module(), web.Module(), ) web模块需要在mqant配置文件中添加配置 \"Module\":{ \"helloworld\":[ { \"Id\":\"helloworld\", \"ProcessID\":\"development\" } ], \"Web\":[ { \"Id\":\"Web001\", \"ProcessID\":\"development\" } ] }, 运行 Server configuration path : //work/go/mqant-helloworld/bin/conf/server.json 2020-05-03T19:59:19.643351+08:00 [-] [-] [development] [I] [app.go:203] mqant starting up 2020-05-03T19:59:19.643603+08:00 [-] [-] [development] [I] [ModuleManager.go:50] This service ModuleGroup(ProcessID) is [development] 2020-05-03T19:59:19.643762+08:00 [-] [-] [development] [I] [rpc_server.go:142] Registering node: HelloWorld@50d3be3d45da93b6 2020-05-03T19:59:19.64951+08:00 [-] [-] [development] [I] [module.go:34] HelloWorld模块初始化完成... 2020-05-03T19:59:19.649629+08:00 [-] [-] [development] [I] [rpc_server.go:142] Registering node: Web@6b3350636a9387de 2020-05-03T19:59:19.64981+08:00 [-] [-] [development] [I] [module.go:38] HelloWorld模块运行中... 2020-05-03T19:59:19.6595+08:00 [-] [-] [development] [I] [module.go:64] web: starting HTTP server :8080 通过浏览器访问 http://127.0.0.1:8080/say?name=mqant 访问结果 hi mqant Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-03 09:38:44 "},"rpc_introduce.html":{"url":"rpc_introduce.html","title":"RPC介绍","keywords":"","body":"说明在模块中使用RPC服务提供者服务调用者说明 mqant RPC本身是一个相对独立的功能,RPC有以下的几个特点: 目前支持nats作为服务发现通道，理论上可以扩展其他通信方式 支持服务注册发现,是一个相对完善的微服务框架 在模块中使用RPC module.BaseModule中已经集成了RPC,使用方式如下 服务提供者 注册hander //注册服务函数 module.GetServer().RegisterGO(_func string, fn interface{}) //注册服务函数 module.GetServer().Register(_func string, fn interface{}) RegisterGO与Register的区别是前者为每一条消息创建一个单独的协程来处理,后者注册的函数共用一个协程来处理所有消息,具体使用哪一种方式可以根据实际情况来定,但Register方式的函数请一定注意不要执行耗时功能,以免引起消息阻塞 服务调用者 在开发过程中，模块A可能需要用到模块B的服务，这时模块A就成为了服务调用方。 mqant提供了多种RPC调用方法,也支持高级扩展(服务发现) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-03 21:58:39 "},"rpc_method.html":{"url":"rpc_method.html","title":"RPC调用方式","keywords":"","body":"RPC路由规则RPC调用方法介绍1. 通过Call函数调度（推荐）特点超时时间设置服务节点选择过滤器moduleType的格式2. 通过RpcInvoke函数调度特点3. 通过InvokeNR函数调度特点4. 指定节点调用所属RPC路由规则 mqant 每一类模块可以部署到多台服务器中,因此需要一个nodeId对同一类模块进行区分。 在框架加入服务注册和发现功能后，nodeId通过服务发现模块在服务启动时自动生成,无法提前编码指定。 RPC调用方法介绍 1. 通过Call函数调度（推荐） /* 通用RPC调度函数 ctx context.Context 上下文,可以设置这次请求的超时时间 moduleType string 服务名称 serverId 或 serverId@nodeId _func string 需要调度的服务方法 param mqrpc.ParamOption 方法传参 opts ...selector.SelectOption 服务发现模块过滤，可以用来选择调用哪个服务节点 */ Call(ctx context.Context, moduleType, _func string, param mqrpc.ParamOption, opts ...selector.SelectOption) (interface{}, string) 特点 支持设置调用超时时间 支持自定义的服务节点选择过滤器 超时时间设置 ctx, _ := context.WithTimeout(context.TODO(), time.Second*3) //3s后超时 rstr,err:=mqrpc.String( self.Call( ctx, \"helloworld\", //要访问的moduleType \"/say/hi\", //访问模块中handler路径 mqrpc.Param(r.Form.Get(\"name\")), ), ) 超时时间仅是调用方有效，超时后无法取消被调用方正在执行的任务。 服务节点选择过滤器 伪代码 ctx, _ := context.WithTimeout(context.TODO(), time.Second*3) rstr,err:=mqrpc.String( self.Call( ctx, \"helloworld\", //要访问的moduleType \"/say/hi\", //访问模块中handler路径 mqrpc.Param(r.Form.Get(\"name\")), selector.WithStrategy(func(services []*registry.Service) selector.Next { var nodes []*registry.Node // Filter the nodes for datacenter for _, service := range services { for _, node := range service.Nodes { if node.Metadata[\"version\"] == \"1.0.0\" { nodes = append(nodes, node) } } } var mtx sync.Mutex //log.Info(\"services[0] $v\",services[0].Nodes[0]) return func() (*registry.Node, error) { mtx.Lock() defer mtx.Unlock() if len(nodes) == 0 { return nil, fmt.Errorf(\"no node\") } index := rand.Intn(int(len(nodes))) return nodes[index], nil } }), ), ) moduleType的格式 指定到模块级别 当moduleType为模块名时 func GetType()值一样，rpc将查找模块已启用的所有节点，然后根据【节点选择过滤器】选择一个节点发起调用 指定到节点级别 格式为 moduleType@moduleID 例如 helloworld@1b0073cbbab33247,rpc将直接选择节点1b0073cbbab33247发起调用 2. 通过RpcInvoke函数调度 module.Invoke(moduleType string, _func string, params ...interface{}) 特点 不支持设置调用超时时间(只能通过配置文件设置全局RPC超时时间) 不支持自定义的服务节点选择过滤器 支持moduleType过滤 3. 通过InvokeNR函数调度 module.InvokeNR(moduleType string, _func string, params ...interface{}) 特点 包涵Invoke所有特点 本函数无需等待返回结果(不会阻塞),仅投递RPC消息 4. 指定节点调用 查找到节点（module.ServerSession），通过节点结构体提供的方法调用 moduleType 模块名称(类型) opts 服务节点选择过滤器 func GetRouteServer(moduleType string, opts ...selector.SelectOption) (s module.ServerSession, err error) SvrSession, err :=self.GetRouteServer(\"helloworld\", selector.WithStrategy(func(services []*registry.Service) selector.Next { var nodes []*registry.Node // Filter the nodes for datacenter for _, service := range services { for _, node := range service.Nodes { if node.Metadata[\"version\"] == \"1.0.0\" { nodes = append(nodes, node) } } } var mtx sync.Mutex //log.Info(\"services[0] $v\",services[0].Nodes[0]) return func() (*registry.Node, error) { mtx.Lock() defer mtx.Unlock() if len(nodes) == 0 { return nil, fmt.Errorf(\"no node\") } index := rand.Intn(int(len(nodes))) return nodes[index], nil } }), ) if err != nil { log.Warning(\"HelloWorld error:%v\", err.Error()) return } rstr, err :=mqrpc.String(SvrSession.Call(ctx, \"/say/hi\", r.Form.Get(\"name\"))) if err != nil { log.Warning(\"HelloWorld error:%v\", err) return } 所属 以上的调用方法在module级别和app级别都有对应实现,可灵活选择 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-03 09:38:44 "},"rpc_data_structure.html":{"url":"rpc_data_structure.html","title":"RPC传参数据结构","keywords":"","body":"RPC数据类型RPC可传参数据类型返回值可使用的参数类型示例RPC数据类型 RPC可传参数据类型 1-9为基础数据类型,可直接使用。10、11为自定义结构体,需要单独定义（章节后续会单独讲解） bool int32 int64 long64 float32 float64 []byte string map[string]interface{} protocol buffer结构体 自定义结构体 注意调用参数不能为nil 如: result,err:=module.Invoke(“user”,\"login\",\"mqant\",nil) 会出现异常无法调用 返回值可使用的参数类型 hander的返回值固定为两个，其中result表示正常业务返回值，err表示异常业务返回值 result: bool int32 int64 long64 float32 float64 []byte string map[string]interface{} protocol buffer结构体 自定义结构体 err: string error 示例 func (self *HellWorld)say(name string) (result string,err error) { return fmt.Sprintf(\"hi %v\",name), nil } result,err:=mqrpc.String( self.Call( ctx, \"helloworld\", //要访问的moduleType \"/say/hi\", //访问模块中handler路径 mqrpc.Param(r.Form.Get(\"name\")), )) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-03 09:38:44 "},"protocolbuffer.html":{"url":"protocolbuffer.html","title":"protocolbuffer","keywords":"","body":"介绍注意事项:代码组织结构编写支持pb传参的handler调用pb的hander测试结果介绍 protocolbuffer结构体(推荐) 注意事项: proto.Message是protocol buffer约定的数据结构,因此需要双方都能够明确数据结构的类型（可以直接断言的） 服务函数返回结构一定要用指针(例如 *rpcpb.ResultInfo)否则mqant无法识别 (见下文) 代码组织结构 首先我们重新组织了一下代码目录结构，新增了一个rpctest目录用来存放rpctest模块代码 工程目录 |-bin |-conf |-server.conf |-helloworld |-module.go |-web |-module.go |-rpctest |-module.go |-main.go 编写支持pb传参的handler 为了简化操作,我们直接使用mqant内部的protocolbuffer结构体rpcpb.ResultInfo var Module = func() module.Module { this := new(rpctest) return this } type rpctest struct { basemodule.BaseModule } func (self *rpctest) GetType() string { //很关键,需要与配置文件中的Module配置对应 return \"rpctest\" } func (self *rpctest) Version() string { //可以在监控时了解代码版本 return \"1.0.0\" } func (self *rpctest) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings) self.GetServer().RegisterGO(\"/test/proto\", self.testProto) } func (self *rpctest) Run(closeSig chan bool) { log.Info(\"%v模块运行中...\",self.GetType()) 调用pb的hander 我们依然在web模块中新加一个api来测试 http.HandleFunc(\"/test/proto\", func(w http.ResponseWriter, r *http.Request) { _ = r.ParseForm() ctx, _ := context.WithTimeout(context.TODO(), time.Second*3) protobean := new(rpcpb.ResultInfo) err:=mqrpc.Proto(protobean,func() (reply interface{}, errstr interface{}) { return self.RpcCall( ctx, \"rpctest\", //要访问的moduleType \"/test/proto\", //访问模块中handler路径 mqrpc.Param(&rpcpb.ResultInfo{Error: *proto.String(r.Form.Get(\"message\"))}), ) }) log.Info(\"RpcCall %v , err %v\",protobean,err) if err!=nil{ _, _ = io.WriteString(w, err.Error()) } _, _ = io.WriteString(w, protobean.Error) }) 测试 http://127.0.0.1:8080/test/proto?message=this%20is%20the%20protocolbuffer%20test 结果 你说: this is the protocolbuffer test Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-27 19:24:18 "},"marshaler.html":{"url":"marshaler.html","title":"自定义数据结构","keywords":"","body":"介绍Marshaler接口定义注意事项:编写支持Marshaler传参的handler定义数据结构新增handler调用marshaler的hander测试结果介绍 跟protocolbuffer类似，mqant也识别mqrpc.Marshaler接口实现的数据结构，开发者只需要自己实现序列化与反序列化即可 Marshaler接口定义 序列化 func (this *mystruct)Marshal() ([]byte, error) 反序列化 func (this *mystruct)Unmarshal(data []byte) error 数据结构名称 func (this *mystruct)String() string 注意事项: 1. mqrpc.Marshaler是请求方和服务方约定的数据结构,因此需要双方都能够明确数据结构的类型（可以直接断言的） 2. 服务函数返回结构一定要用指针(例如*rsp)否则mqant无法识别 (见下文) 编写支持Marshaler传参的handler 首先我们重新组织了一下代码目录结构，新增了一个marshaler.go用来存放自定义数据结构代码 工程目录 |-bin |-conf |-server.conf |-helloworld |-module.go |-web |-module.go |-rpctest |-module.go |-marshaler.go |-main.go 定义数据结构 package rpctest //请求数据结构 type Req struct { Id string } func (this *Req) Marshal() ([]byte, error) { return []byte(this.Id), nil } func (this *Req) Unmarshal(data []byte) error { this.Id = string(data) return nil } func (this *Req) String() string { return \"req\" } //响应数据结构 type Rsp struct { Msg string } func (this *Rsp) Marshal() ([]byte, error) { return []byte(this.Msg), nil } func (this *Rsp) Unmarshal(data []byte) error { this.Msg = string(data) return nil } func (this *Rsp) String() string { return \"rsp\" } 新增handler self.GetServer().RegisterGO(\"/test/marshal\", self.testMarshal) ... func (self *rpctest) testMarshal(req Req) (*Rsp, error) { r := &Rsp{Msg: fmt.Sprintf(\"你的ID：%v\",req.Id)} return r, nil } 调用marshaler的hander 我们依然在web模块中新加一个api来测试 http.HandleFunc(\"/test/marshal\", func(w http.ResponseWriter, r *http.Request) { _ = r.ParseForm() ctx, _ := context.WithTimeout(context.TODO(), time.Second*3) rspbean := new(rpctest.Rsp) err:=mqrpc.Marshal(rspbean,func() (reply interface{}, errstr interface{}) { return self.Call( ctx, \"rpctest\", //要访问的moduleType \"/test/marshal\", //访问模块中handler路径 mqrpc.Param(&rpctest.Req{Id: r.Form.Get(\"mid\")}), ) }) log.Info(\"RpcCall %v , err %v\",rspbean,err) if err!=nil{ _, _ = io.WriteString(w, err.Error()) } _, _ = io.WriteString(w, rspbean.Msg) }) 测试 http://127.0.0.1:8080/test/marshal?mid=1314 结果 你的ID：1314 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-03 09:38:44 "},"data_structure_assertion.html":{"url":"data_structure_assertion.html","title":"RPC返回结果断言","keywords":"","body":"概述断言函数介绍protocolbuffer断言自定义结构断言字符串断言其他类型断言概述 由于RpcCall是一个通用函数,我们无法对其返回值指定类型,为了简化代码，mqant参考redis封装了几个RPC返回类型断言函数,方便开发者使用 断言函数介绍 protocolbuffer断言 protobean := new(rpcpb.ResultInfo) err:=mqrpc.Proto(protobean,func() (reply interface{}, errstr interface{}) { return self.Call( ctx, \"rpctest\", //要访问的moduleType \"/test/proto\", //访问模块中handler路径 mqrpc.Param(&rpcpb.ResultInfo{Error: *proto.String(r.Form.Get(\"message\"))}), ) }) log.Info(\"RpcCall %v , err %v\",protobean,err) 自定义结构断言 rspbean := new(rpctest.Rsp) err:=mqrpc.Marshal(rspbean,func() (reply interface{}, errstr interface{}) { return self.Call( ctx, \"rpctest\", //要访问的moduleType \"/test/marshal\", //访问模块中handler路径 mqrpc.Param(&rpctest.Req{Id: \"hello 我是RpcInvoke\"}), ) }) log.Info(\"RpcCall %v , err %v\",rspbean,err) 字符串断言 rstr,err:=mqrpc.String( self.Call( context.Background(), \"helloworld\", \"/say/hi\", mqrpc.Param(r.Form.Get(\"name\")), ), ) log.Info(\"RpcCall %v , err %v\",rstr,err) 其他类型断言 int bool map\\[string\\]string .... Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-03 09:38:44 "},"server_introduce.html":{"url":"server_introduce.html","title":"服务续约","keywords":"","body":"基本原理解决办法设置基本原理 服务在启动时注册服务发现，并在关闭时取消注册。有时这些服务可能会意外死亡，被强行杀死或面临暂时的网络问题。在这些情况下，遗留的节点将存在服务发现中。 解决办法 服务发现支持注册的TTL选项和间隔。TTL指定在发现之后注册的信息存在多长时间，然后过期并被删除。时间间隔是服务应该重新注册的时间，以保留其在服务发现中的注册信息。 设置 mqant默认的ttl=20，重新注册间隔为10秒 func (self *rpctest) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings, server.RegisterInterval(15*time.Second), server.RegisterTTL(30*time.Second), ) } 以上这个例子，我们设置了一个30秒的ttl，重新注册间隔为15秒。如果应用进程被强杀,服务未取消注册,则30秒内其他服务节点无法感知改节点已失效。 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 10:47:31 "},"server_metadata.html":{"url":"server_metadata.html","title":"服务元数据","keywords":"","body":"介绍节点ID启动调用服务版本（Version）元数据（Metadata）设置元数据立即刷新示例介绍 服务还支持设置元数据，即服务的自身属性，通过这些属性我们可以定制服务发现策略。 节点ID 一般情况下节点ID在模块初始化时由系统自动生成一个不重复的随机数，但我们也可以指定节点ID func (self *rpctest) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings, server.RegisterInterval(15*time.Second), server.RegisterTTL(30*time.Second), server.Id(\"mynode001\"), ) } 启动 2020-05-05T11:06:35.224305+08:00 [-] [-] [development] [I] [rpc_server.go:142] Registering node: Web@a6a49427222f84c4 2020-05-05T11:06:35.224656+08:00 [-] [-] [development] [I] [module.go:39] HelloWorld模块运行中... 2020-05-05T11:06:35.232826+08:00 [-] [-] [development] [I] [rpc_server.go:142] Registering node: rpctest@mynode001 2020-05-05T11:06:35.233042+08:00 [-] [-] [development] [I] [module.go:179] web: starting HTTP server :8080 2020-05-05T11:06:35.241667+08:00 [-] [-] [development] [I] [module.go:46] rpctest模块运行中... 调用 如果明确知道节点ID,那你可以这样直接找到它,虽然通常不这样用 err:=mqrpc.Marshal(rspbean,func() (reply interface{}, errstr interface{}) { return self.Call( ctx, \"rpctest@mynode001\", //要访问的moduleType \"/test/marshal\", //访问模块中handler路径 mqrpc.Param(&rpctest.Req{Id: r.Form.Get(\"mid\")}), ) }) 服务版本（Version） 模块（服务）启动是,会自动注册模块func Version() string 的返回值作为服务的版本 如果你愿意可以利用服务版本过滤节点 rstr,err:=mqrpc.String( self.Call( ctx, \"helloworld\", //要访问的moduleType \"/say/hi\", //访问模块中handler路径 mqrpc.Param(r.Form.Get(\"name\")), selector.WithStrategy(func(services []*registry.Service) selector.Next { var nodes []*registry.Node // Filter the nodes for datacenter for _, service := range services { if service.Version!= \"1.0.0\"{ continue } for _, node := range service.Nodes { nodes = append(nodes, node) } } var mtx sync.Mutex //log.Info(\"services[0] $v\",services[0].Nodes[0]) return func() (*registry.Node, error) { mtx.Lock() defer mtx.Unlock() if len(nodes) == 0 { return nil, fmt.Errorf(\"no node\") } index := rand.Intn(int(len(nodes))) return nodes[index], nil } }), ), ) 元数据（Metadata） 你还可以为服务节点指定设置元数据，元数据是节点级别的,且可以随时修改,利用好它可以灵活的实现定制化的服务发现 比如实现灰度发布,熔断策略等等 设置元数据 self.GetServer().Options().Metadata[\"state\"]=\"alive\" 立即刷新 设置好的元数据会等到下一次重新注册是更新到配置中心并同步至其他节点，如果我们想立即生效的话可以这样做 _ := self.GetServer().ServiceRegister() 示例 rstr,err:=mqrpc.String( self.Call( ctx, \"helloworld\", //要访问的moduleType \"/say/hi\", //访问模块中handler路径 mqrpc.Param(r.Form.Get(\"name\")), selector.WithStrategy(func(services []*registry.Service) selector.Next { var nodes []*registry.Node // Filter the nodes for datacenter for _, service := range services { if service.Version!= \"1.0.0\"{ continue } for _, node := range service.Nodes { nodes = append(nodes, node) if node.Metadata[\"state\"] == \"alive\" || node.Metadata[\"state\"] == \"\" { nodes = append(nodes, node) } } } var mtx sync.Mutex //log.Info(\"services[0] $v\",services[0].Nodes[0]) return func() (*registry.Node, error) { mtx.Lock() defer mtx.Unlock() if len(nodes) == 0 { return nil, fmt.Errorf(\"no node\") } index := rand.Intn(int(len(nodes))) return nodes[index], nil } }), ), ) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-03 09:38:44 "},"selector.html":{"url":"selector.html","title":"服务选择","keywords":"","body":"概述用法默认选择器RPC级别应用级别概述 紧跟上一章内容,微服务中每一个服务都会部署多个节点，并且根据实际情况我们还可能临时新增或摘除节点， 通常节点选择是结合业务而定的，因此灵活的节点选择器是框架必备的功能 用法 mqant的节点选择器（selector）是从go-mirco移植而来的,其使用规则可参考go-mirco实现 默认选择器 mqant默认的选择器是一个随机负载均衡选择器 RPC级别 如果需要针对某一个RPC调用定制选择器可以这样做 RpcCall 函数可选参数中支持设置选择器 rstr,err:=mqrpc.String( self.RpcCall( ctx, \"helloworld\", //要访问的moduleType \"/say/hi\", //访问模块中handler路径 mqrpc.Param(r.Form.Get(\"name\")), selector.WithStrategy(func(services []*registry.Service) selector.Next { var nodes []*registry.Node // Filter the nodes for datacenter for _, service := range services { if service.Version!= \"1.0.0\"{ continue } for _, node := range service.Nodes { nodes = append(nodes, node) if node.Metadata[\"state\"] == \"alive\" || node.Metadata[\"state\"] == \"\" { nodes = append(nodes, node) } } } var mtx sync.Mutex //log.Info(\"services[0] $v\",services[0].Nodes[0]) return func() (*registry.Node, error) { mtx.Lock() defer mtx.Unlock() if len(nodes) == 0 { return nil, fmt.Errorf(\"no node\") } index := rand.Intn(int(len(nodes))) return nodes[index], nil } }), ), ) 应用级别 大部分情况下,我们只需要定制一个全局统一的通用选择器，那么可以在应用(app)级别设置 app := mqant.CreateApp( module.Debug(false), ) _ = app.Options().Selector.Init(selector.SetStrategy(func(services []*registry.Service) selector.Next { var nodes []WeightNode // Filter the nodes for datacenter for _, service := range services { for _, node := range service.Nodes { weight := 100 if w, ok := node.Metadata[\"weight\"]; ok { wint, err := strconv.Atoi(w) if err == nil { weight = wint } } if state, ok := node.Metadata[\"state\"]; ok { if state != \"forbidden\" { nodes = append(nodes, WeightNode{ Node: node, Weight: weight, }) } } else { nodes = append(nodes, WeightNode{ Node: node, Weight: weight, }) } } } //log.Info(\"services[0] $v\",services[0].Nodes[0]) return func() (*registry.Node, error) { if len(nodes) == 0 { return nil, fmt.Errorf(\"no node\") } rand.Seed(time.Now().UnixNano()) //按权重选 total := 0 for _, n := range nodes { total += n.Weight } if total > 0 { weight := rand.Intn(total) togo := 0 for _, a := range nodes { if (togo 以上的选择器利用节点元数据(Metadata)定制了一个节点选择规则 按权重(weight) 按节点当前状态(forbidden) 最后降级为随机 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-06 14:22:46 "},"configuration_introduce.html":{"url":"configuration_introduce.html","title":"配置文件结构","keywords":"","body":"概述结构概述 配置文件可分为五大块 应用级别配置 模块(服务)配置 日志配置 结构 配置文件是json格式 { \"Settings\":{ }, \"Module\":{ \"moduletype\":[ { \"Id\":\"moduletype\", \"ProcessID\":\"development\", \"Settings\":{ } } ], }, \"Log\": { } } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 12:12:06 "},"configuration_app.html":{"url":"configuration_app.html","title":"应用级别配置","keywords":"","body":"应用级别配置在应用中获取在模块中获取应用级别配置 应用级别配置可以设置应用全局所要用到的配置，例如数据库连接地址等等 { \"Settings\":{ \"MongodbURL\": \"mongodb://xx:xx@xx:8015\", \"MongodbDB\": \"xx-server\" } } 在应用中获取 _ = app.OnConfigurationLoaded(func(app module.App) { tools.MongodbUrl = app.GetSettings().Settings[\"MongodbURL\"].(string) tools.MongodbDB = app.GetSettings().Settings[\"MongodbDB\"].(string) } 在模块中获取 func (self *admin_web) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings) tools.MongodbUrl = app.GetSettings().Settings[\"MongodbURL\"].(string) tools.MongodbDB = app.GetSettings().Settings[\"MongodbDB\"].(string) } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 12:07:02 "},"configuration_module.html":{"url":"configuration_module.html","title":"模块级别配置","keywords":"","body":"模块配置分组ID（ProcessID)模块自定义配置使用模块配置 模块配置分两大部分 模块的启动分组ProcessID 模块级别的自定义配置 分组ID（ProcessID) 分组ID在分布式部署中非常重要稍后会详细讲解,mqant的默认分组为development 模块自定义配置 \"Module\":{ \"moduletype\":[ { \"Settings\":{ \"StaticPath\": \"static\", \"Port\": 6010 } } ], } 使用 func (self *admin_web) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings) self.StaticPath = self.GetModuleSettings().Settings[\"StaticPath\"].(string) self.Port = int(self.GetModuleSettings().Settings[\"Port\"].(float64)) } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 12:08:16 "},"configuration_log.html":{"url":"configuration_log.html","title":"日志配置","keywords":"","body":"概述特性输出引擎文件输出使用方法配置方式配置与beego的一些区别引擎字段映射关闭控制台打印概述 mqant使用beego/logs日志模块 特性 输出引擎 支持的引擎有 file、console、net、smtp、dingtalk(钉钉) 、es(ElasticSearch)、jianliao(简聊)、slack 文件输出 1. 按照每天输出文件 2. 可限制每个文件最大写入行 3. 可限制每个文件最大文件大小 4. error，access类日志分文件输出 使用方法 配置方式 mqant的日志配置选项基本与beego的日志配置字段保持一致,可参考 beego日志配置文档 在mqant的配置文件server.json中的Log字段内配置。 eg. server.json { \"Log\":{ \"dingtalk\":{ \"webhookurl\":\"https://oapi.dingtalk.com/robot/send?access_token=xxx\", // RFC5424 log message levels. \"level\":3 }, \"file\":{ //是否按照每天 logrotate，默认是 true \"daily\":true, \"level\":7 } } } 配置与beego的一些区别 每一种引擎都需要在Log中配置才能生效(file引擎除外) file是默认引擎，Log不配置的话会使用默认配置 file引擎的filename字段无法设置，mqant会默认为access级别和error级别的日志分文件输出到约定的日志目录中 引擎字段映射 文件输出 file 邮件输出 smtp 简聊 jianliao slack slack 钉钉 dingtalk 网络 conn ElasticSearch es 关闭控制台打印 在正式环境中我们只需要在file中输出日志，不需要再控制台输出日志了，因此我们需要关闭控制台日志输出。 app := mqant.CreateApp( module.Debug(false), //只有是在调试模式下才会在控制台打印日志, 非调试模式下只在日志文件中输出日志 ) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 12:11:04 "},"deployment_introduce.html":{"url":"deployment_introduce.html","title":"部署概述","keywords":"","body":"概述模块分组(ProcessID)单机部署模块ProcessID设置指定进程ProcessID编译运行概述 mqant部署分为单机部署和分布式部署,通常情况下,项目的所有模块代码都被编译到一个可执行文件中。 在分布式部署时,我们通常想将网关模块跟后端服务模块分服务器部署，即： 网关服务器仅启用网关模块 后端服务器仅启用后端模块 模块分组(ProcessID) 模块分组便是为了实现上面的功能而设计的,如果要不同的模块分开部署可以按如下步骤操作 在配置文件中将模块的ProcessID分开 在启动应用进程时指定进程ProcessID 单机部署 mqant默认的模块分组值约定为development 在调试期间可以将所有模块的分组ID都设置为development,这样一个进程就可以启用所有已实现的模块 模块ProcessID设置 \"Module\":{ \"moduletype\":[ { \"Id\":\"moduletype\", \"ProcessID\":\"development\" } ] } 指定进程ProcessID pid := flag.String(\"pid\", \"\", \"Server work directory\") flag.Parse() //解析输入的参数 app := mqant.CreateApp( module.Debug(true), //只有是在调试模式下才会在控制台打印日志, 非调试模式下只在日志文件中输出日志 module.Parse(false), module.ProcessID(*pid), ) 编译 sh build.sh 运行 mqant-example -pid mypid Server configuration path : /work/go/mqant-example/bin/conf/server.json 2020-05-05T17:15:46.48651+08:00 [-] [-] [mypid] [I] [app.go:209] mqant starting up 2020-05-05T17:15:46.486779+08:00 [-] [-] [mypid] [I] [ModuleManager.go:50] This service ModuleGroup(ProcessID) is [mypid] Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-11 17:11:57 "},"startup_parameter.html":{"url":"startup_parameter.html","title":"启动参数","keywords":"","body":"mqant默认解析参数mqant解析字段关闭mqant解析指定进程工作路径启动命令设置初始化设置工作路径指定配置文件启动命令设置初始化设置指定模块分组ID启动命令设置初始化设置mqant默认解析参数 mqant默认会解析启动环境变量,即调用flag.Parse(),如不想mqant解析可通过启动方法module.Parse(false)关闭 mqant解析字段 wdPath = *flag.String(\"wd\", \"\", \"Server work directory\") confPath = *flag.String(\"conf\", \"\", \"Server configuration file path\") ProcessID = *flag.String(\"pid\", \"development\", \"Server ProcessID?\") Logdir = *flag.String(\"log\", \"\", \"Log file directory?\") BIdir = *flag.String(\"bi\", \"\", \"bi file directory?\") 关闭mqant解析 app := mqant.CreateApp( module.Parse(false), #关闭后mqant所需参数需设置 ) 指定进程工作路径 启动命令设置 module.Parse(true) 命令 wd mqant-example -wd /my/workdir 初始化设置 module.Parse(false) app := mqant.CreateApp( module.Parse(false), module.WorkDir(\"/my/workdir\"), ) 工作路径 mqant会在工作路径下初始化未指定的设置 配置文件 {workdir}/bin/conf/server.json 日志文件目录 {workdir}/bin/logs BI日志文件目录 {workdir}/bin/bi 指定配置文件 启动命令设置 module.Parse(true) 命令 conf mqant-example -conf /my/config.json 初始化设置 module.Parse(false)app := mqant.CreateApp( module.Parse(false), module.Configure(\"/my/config.json\"), ) 指定模块分组ID 启动命令设置 module.Parse(true) 命令 pid mqant-example -pid myPid 初始化设置 module.Parse(false)app := mqant.CreateApp( module.Parse(false), module.ProcessID(\"myPid\"), ) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 17:39:10 "},"service_discovery_parameter.html":{"url":"service_discovery_parameter.html","title":"服务发现设置","keywords":"","body":"概述示例概述 服务发现配置只能通过启动代码设置,包涵 nats配置 注册中心配置(consul,etcd) 服务发现TTL和注册间隔 示例 app := mqant.CreateApp( module.Debug(true), //只有是在调试模式下才会在控制台打印日志, 非调试模式下只在日志文件中输出日志 module.Nats(nc), //指定nats rpc module.Registry(rs), //指定服务发现 module.RegisterTTL(20*time.Second), module.RegisterInterval(10*time.Second), ) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 17:46:14 "},"dynamic_handler.html":{"url":"dynamic_handler.html","title":"动态监听handler","keywords":"","body":"概述handler监听器设置监听器示例监听器实现请求转发器实现概述 有些场景下,我们无法在编译阶段提前实现或注册好所有的handler,但在执行时可以通过一些动态规则动态分配handler。 mqant也支持这样的功能场景 handler监听器 type RPCListener interface { /** NoFoundFunction 当未找到请求的handler时会触发该方法 *FunctionInfo 选择可执行的handler return error */ NoFoundFunction(fn string) (*FunctionInfo, error) /** BeforeHandle会对请求做一些前置处理，如：检查当前玩家是否已登录，打印统计日志等。 @session 可能为nil return error 当error不为nil时将直接返回改错误信息而不会再执行后续调用 */ BeforeHandle(fn string, callInfo *CallInfo) error OnTimeOut(fn string, Expired int64) OnError(fn string, callInfo *CallInfo, err error) /** fn 方法名 params 参数 result 执行结果 exec_time 方法执行时间 单位为 Nano 纳秒 1000000纳秒等于1毫秒 */ OnComplete(fn string, callInfo *CallInfo, result *rpcpb.ResultInfo, exec_time int64) } 设置监听器 func (self *HttpGateWay) OnInit(app module.App, settings *conf.ModuleSettings) { self.SetListener(self) } 示例 我们实现一个http网关路由示例，将handler转换为http请求的path路由 监听器实现 func (self *HttpGateWay) NoFoundFunction(fn string)(*mqrpc.FunctionInfo,error){ return &mqrpc.FunctionInfo{ Function:reflect.ValueOf(self.CloudFunction), Goroutine:true, },nil } func (self *HttpGateWay) BeforeHandle(fn string, callInfo *mqrpc.CallInfo) error{ return nil } func (self *HttpGateWay) OnTimeOut(fn string, Expired int64){ } func (self *HttpGateWay) OnError(fn string, callInfo *mqrpc.CallInfo, err error){} /** fn 方法名 params 参数 result 执行结果 exec_time 方法执行时间 单位为 Nano 纳秒 1000000纳秒等于1毫秒 */ func (self *HttpGateWay) OnComplete(fn string, callInfo *mqrpc.CallInfo, result *rpcpb.ResultInfo, exec_time int64){} 请求转发器实现 一下是一段伪代码 监听http网关的请求 解析http的path(url) 填充http请求参数 通过httptest模拟http请求 将结果返回http网关 func (self *HttpGateWay) CloudFunction(trace log.TraceSpan,request *go_api.Request) (*go_api.Response,error) { e := echo.New() ectest := httgatewaycontrollers.SetupRouter(self, e) req, err := http.NewRequest(request.Method, request.Url, strings.NewReader(request.Body)) if err != nil { return nil,err } for _,v:=range request.Header{ req.Header.Set(v.Key, strings.Join(v.Values,\",\")) } rr := httptest.NewRecorder() ectest.ServeHTTP(rr, req) resp := &go_api.Response{ StatusCode: int32(rr.Code), Body: rr.Body.String(), Header: make(map[string]*go_api.Pair), } for key, vals := range rr.Header() { header, ok := resp.Header[key] if !ok { header = &go_api.Pair{ Key: key, } resp.Header[key] = header } header.Values = vals } return resp,nil } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 18:27:27 "},"global_monitoring_handler.html":{"url":"global_monitoring_handler.html","title":"全局监听handler","keywords":"","body":"概述应用级别handler监控调用方监控服务方监控概述 我们通常希望能监控handler的具体执行情况,例如做监控报警等等 应用级别handler监控 app := mqant.CreateApp( module.SetClientRPChandler(func(app module.App, server registry.Node, rpcinfo rpcpb.RPCInfo, result interface{}, err string, exec_time int64) { }), module.SetServerRPCHandler(func(app module.App, server module.Module, callInfo mqrpc.CallInfo) { }), ) 调用方监控 module.SetClientRPChandler(func(app module.App, server registry.Node, rpcinfo rpcpb.RPCInfo, result interface{}, err string, exec_time int64) { }) 服务方监控 module.SetServerRPCHandler(func(app module.App, server module.Module, callInfo mqrpc.CallInfo) { }) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 18:33:27 "},"gate_introduce.html":{"url":"gate_introduce.html","title":"网关介绍","keywords":"","body":"概述特性:使用Gate网关模块概述 mqant中的Gate网关模块相对来说非常重要,它支撑了服务器与客户端的长连接通信 特性: 支撑tcp，websocket通信方式 默认支撑MQTT协议 可自定义通信协议 使用Gate网关模块 gate网关模块包含的功能虽然多,但在实际开发时并不需要做过多的二次开发, 开发者只需要继承basegate.Gate这个基础模块即可,示例如下: type Gate struct { basegate.Gate //继承 } func (this *Gate) GetType() string { //很关键,需要与配置文件中的Module配置对应 return \"Gate\" } func (this *Gate) Version() string { //可以在监控时了解代码版本 return \"1.0.0\" } func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { //注意这里一定要用 gate.Gate 而不是 module.BaseModule this.Gate.OnInit(this, app, settings) } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 18:38:39 "},"mqtt.html":{"url":"mqtt.html","title":"mqtt协议","keywords":"","body":"概述消息体概述主题(topic)消息体(body)如何使用MQTT协议实现游戏路由概述 MQTT协议是为大量计算能力有限，且工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性： 使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合； 对负载内容屏蔽的消息传输； 使用 TCP/IP 提供网络连接； 有三种消息发布服务质量： “至多一次”，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。 “至少一次”，确保消息到达，但消息重复可能会发生。 “只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。 小型传输，开销很小（固定长度的头部是 2 字节），协议交换最小化，以降低网络流量； 使用 Last Will 和 Testament 特性通知有关各方客户端异常中断的机制； 总的说来MQTT协议是非常精简的通信协议,同时也有完善的【心跳包检测】和【重连机制】,很适合移动游戏环境使用 消息体概述 除去MQTT协议的实现,在实际游戏过程中我们可以只需要关注以下内容: MQTT协议消息体由两部分组成【topic】和【body】 主题(topic) MQTT是通过主题对消息进行分类的，本质上就是一个UTF-8的字符串，不过可以通过反斜杠表示多个层级关系。主题并不需要创建，直接使用就是了。 主题还可以通过通配符进行过滤。其中，+可以过滤一个层级，而*只能出现在主题最后表示过滤任意级别的层级。 举个例子： baidu/chatroom：代表百度公司的聊天室。 +/chatroom：代表任何公司的聊天室。 baidu/*：代表百度公司所有的子频道 消息体(body) 消息体是二进制数据流 如何使用MQTT协议实现游戏路由 由于mqant目前主要用于游戏开发,因此mqant只使用了mqtt协议的一小部分功能。 mqant网关将收到信息topic解析出moduleType和handler用来定位到后端模块的对应处理方法,然后进行远程RPC调用。msgid作为客户端是否需要消息应答的的标记 如下图: Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 18:55:51 "},"first_gate.html":{"url":"first_gate.html","title":"编写第一个网关","keywords":"","body":"代码组织结构编写第一个网关网关监听端口运行编写第一个客户端主动发起请求监听服务器主动下发消息编写后端handlerhandler实现注册handler主动给客户端发送消息运行客户端(robot)后续代码组织结构 首先我们重新组织了一下代码目录结构，新增了一个gate目录用来存放网关代码,robot目录用来存放访问网关的mqtt客户端代码 工程目录 |-bin |-conf |-server.conf |-helloworld |-module.go |-xxx.go |-gate |-module.go |-robot |-test |-manager.go |-work.go |-robot_task.go |-main.go 编写第一个网关 package mgate import ( \"github.com/liangdas/mqant/conf\" \"github.com/liangdas/mqant/gate\" \"github.com/liangdas/mqant/gate/base\" \"github.com/liangdas/mqant/module\" ) var Module = func() module.Module { gate := new(Gate) return gate } type Gate struct { basegate.Gate //继承 } func (this *Gate) GetType() string { //很关键,需要与配置文件中的Module配置对应 return \"Gate\" } func (this *Gate) Version() string { //可以在监控时了解代码版本 return \"1.0.0\" } func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { //注意这里一定要用 gate.Gate 而不是 module.BaseModule this.Gate.OnInit(this, app, settings, gate.WsAddr(\":3653\"), gate.TcpAddr(\":3563\"), ) } 网关监听端口 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { //注意这里一定要用 gate.Gate 而不是 module.BaseModule this.Gate.OnInit(this, app, settings, gate.WsAddr(\":3653\"), gate.TcpAddr(\":3563\"), ) } 运行 2020-05-05T20:12:32.5603+08:00 [-] [-] [development] [I] [rpc_server.go:142] Registering node: Gate@ba5ccc4ce9feb31c 2020-05-05T20:12:32.568484+08:00 [-] [-] [development] [I] [module.go:45] rpctest模块运行中... 2020-05-05T20:12:32.573808+08:00 [-] [-] [development] [I] [ws_server_x.go:131] WS Listen ::3653 2020-05-05T20:12:32.574043+08:00 [-] [-] [development] [I] [tcp_server.go:39] TCP Listen ::3563 编写第一个客户端 核心逻辑在robot/test/work.go package test_task import ( \"encoding/json\" \"fmt\" MQTT \"github.com/eclipse/paho.mqtt.golang\" \"github.com/liangdas/armyant/task\" \"github.com/liangdas/armyant/work\" ) func NewWork(manager *Manager) *Work { this := new(Work) this.manager = manager //opts := this.GetDefaultOptions(\"tcp://127.0.0.1:3563\") opts := this.GetDefaultOptions(\"ws://127.0.0.1:3653\") opts.SetConnectionLostHandler(func(client MQTT.Client, err error) { fmt.Println(\"ConnectionLost\", err.Error()) }) opts.SetOnConnectHandler(func(client MQTT.Client) { fmt.Println(\"OnConnectHandler\") }) err := this.Connect(opts) if err != nil { fmt.Println(err.Error()) } this.On(\"/gate/send/test\", func(client MQTT.Client, msg MQTT.Message) { fmt.Println(msg.Topic(), string(msg.Payload())) }) return this } /** Work 代表一个协程内具体执行任务工作者 */ type Work struct { work.MqttWork manager *Manager } func (this *Work) UnmarshalResult(payload []byte) map[string]interface{} { rmsg := map[string]interface{}{} json.Unmarshal(payload, &rmsg) return rmsg[\"Result\"].(map[string]interface{}) } /** 每一次请求都会调用该函数,在该函数内实现具体请求操作 task:=task.Task{ N:1000, //一共请求次数，会被平均分配给每一个并发协程 C:100, //并发数 //QPS:10, //每一个并发平均每秒请求次数(限流) 不填代表不限流 } N/C 可计算出每一个Work(协程) RunWorker将要调用的次数 */ func (this *Work) RunWorker(t task.Task) { msg, err := this.Request(\"helloworld/HD_say\", []byte(`{\"name\":\"mqant\"}`)) if err != nil { return } fmt.Println(msg.Topic(), string(msg.Payload())) } func (this *Work) Init(t task.Task) { } func (this *Work) Close(t task.Task) { this.GetClient().Disconnect(0) } 主动发起请求 给后端helloworld发起一个handler(HD_say)调用 msg, err := this.Request(\"helloworld/HD_say\", []byte(`{\"name\":\"mqant\"}`)) if err != nil { return } fmt.Println(msg.Topic(), string(msg.Payload())) 监听服务器主动下发消息 this.On(\"/gate/send/test\", func(client MQTT.Client, msg MQTT.Message) { fmt.Println(msg.Topic(), string(msg.Payload())) }) 编写后端handler handler实现 func (self *HellWorld) gatesay(session gate.Session,msg map[string]interface{}) (r string, err error) { session.Send(\"/gate/send/test\",[]byte(fmt.Sprintf(\"send hi to %v\", msg[\"name\"]))) return fmt.Sprintf(\"hi %v 你在网关 %v\", msg[\"name\"],session.GetServerId()), nil } 注册handler self.GetServer().RegisterGO(\"HD_say\", self.gatesay) 主动给客户端发送消息 session.Send(\"/gate/send/test\",[]byte(fmt.Sprintf(\"send hi to %v\", msg[\"name\"]))) 运行客户端(robot) go run robot_task.go 开始压测请等待 Connect... OnConnectHandler /gate/send/test send hi to mqant helloworld/HD_say/1 {\"Trace\":\"5f7f87ee73f79b7a\",\"Error\":\"\",\"Result\":\"hi mqant 你在网关 Gate@1a8a1b29c7496c04\"} 后续 下一章我们讲解网关的路由协议如何工作的。 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-06 14:22:46 "},"gateway_routing.html":{"url":"gateway_routing.html","title":"网络路由协议","keywords":"","body":"概述通信模式默认路由协议概述 上一章我们实现了第一个网关,并且还实现了客户端跟后端模块之间的通信,但并没有详细阐述其中的路由原理，以下章节内容将详细讲解网关的路由协议和数据结构 通信模式 mqant是支持与客户端双向通信的长连接框架,与客户端通信有以下三种模式 Request-Response模式 类似http的Request--Response模式，一问一答。 Request-NoResponse模式 客户端发出消息后不需要服务端回答，一问。 ServerPush模式 服务器主动给客户端发送消息与app的推送功能相似 Request-NoResponse模式通常与ServerPush模式配合使用,当后端异步响应客户端消息时非常有用 默认路由协议 mqant网关是这样进行约定的 topic格式约定 [moduleType]/[handler]/[msgid] moduleType 模块名称 handler 模块中的的方法 msgid 本次消息唯一ID [可选] mqant网关将收到信息topic解析为以上三部分,moduleType、handler、msgid。 moduleType和handler其中用来定位到后端模块的对应处理方法,然后进行远程RPC调用。 msgid作为客户端是否需要消息应答的的标记,即类似http的Request-Response模式。 如果不设置msgid就是Request-NoResponse模式 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 20:47:37 "},"gateway_session.html":{"url":"gateway_session.html","title":"session","keywords":"","body":"概述网关与后端通信session定义组成它的大致字段如下：功能给客户端发送消息不阻塞给客户端发消息绑定uid设置一个远程属性获取一个属性同步网关最新数据批量设置远程属性判断session是否游客自定义游客判断规则特性序列化持久化session监听器设置监听器概述 在上面章节中,gate handler传参第一个参数是session gate.Session,本章节将详细阐述session的原理和用法 网关与后端通信 在客户端通过网关向后端业务模块发送消息时，网关会将session放在第一个参数，因此再设计handler是需要将第一个参数定义为session func (self *HellWorld) gatesay(session gate.Session,msg map[string]interface{}) (r string, err error) { session.Send(\"/gate/send/test\",[]byte(fmt.Sprintf(\"send hi to %v\", msg[\"name\"]))) return fmt.Sprintf(\"hi %v 你在网关 %v\", msg[\"name\"],session.GetServerId()), nil } session定义 Session是由Gate网关模块维护的,代表客户端跟网关建立的一条连接,session封装了网关和客户端连接的信息 组成 网关信息 连接自定义信息 它的大致字段如下： { Userid string IP string Network string Sessionid string Serverid string Settings } Userid 需要调用Bind绑定来设置 默认为\"\" 当客户端登陆以后可以设置该参数,其他业务模块通过判断Userid来判断该连接是否合法 IP客户端IP地址 Network网络类型 TCP websocket ... SessionidGate网关模块生成的该连接唯一ID Serverid Gate网关模块唯一ID，后端模块可以通过它来与Gate网关进行RPC调用 Settings 可以给这个连接设置一些参数,例如当用户加入对战房间以后可以设置一个参数 roomName=\"mqant\" 功能 session最大的功能是它封装了跟网关通信的方法，利用session我们可以给客户端发送消息 给客户端发送消息 遵守mqtt的主题(topic) 、消息体(body) session.Send(\"/gate/send/test\",[]byte(fmt.Sprintf(\"send hi to %v\", msg[\"name\"]))) 不阻塞给客户端发消息 如果只想发送消息，但不想知道发送结果,则可以使用一下的方法,它不会阻塞协程 session.SendNR(\"/gate/send/test\",[]byte(fmt.Sprintf(\"send hi to %v\", msg[\"name\"]))) 绑定uid 连接建立后并没有任何用户属性，当用户通过该连接登陆后,可以将uid绑定到session上，这样session也就跟用户关联到一起了 session.Bind(\"userId\") 设置一个远程属性 session.SetPush(key,value) 获取一个属性 session.Get(key) 同步网关最新数据 通常session.SetPush，session.SetBatch也会同步最新数据 session.Push() //如果想同步网关最新数据 批量设置远程属性 每调用一次session.SetPush就会进行一次RPC通信，如果有多个属性需要设置的话可以合并批量设置 session.SetBatch(map[string]string) 判断session是否游客 session.IsGuest() 自定义游客判断规则 func main() { gate.JudgeGuest= func(session gate.Session) bool { if session.GetUserId()!=\"\"{ return false } return true } } 特性 session最新的信息都由网关维护,也就是说只要不是最新从网关同步来的session,信息都有可能是不完整或者错误的。 时效性 session跟客户端连接直接挂钩,如果连接中断session即失效 不确定性 如果客户端连接中断重连,可能从网关1切换成网关2,那么以前持有的session则失效 可序列化 合理利用session可以提高 序列化 bytes, err := session.Serializable() app module.App session, err := basegate.NewSession(app, bytes) 持久化 如果我们不希望客户端网络中断以后导致Session自定义数据丢失,以保证客户端在指定时间内重连以后能继续使用这些数据,我们需要对用户的Session进行持久化 Gate网关模块目前提供一个接口用来控制Session的持久化,但具体的持久化方式需要开发者自己来实现 session监听器 type StorageHandler interface { /** 存储用户的Session信息,触发条件 1. session.Bind(Userid) 2. session.SetPush(key,value) 3. session.SetBatch(map[string]string) */ Storage(session Session) (err error) /** 强制删除Session信息,触发条件 1. 暂无 */ Delete(session Session) (err error) /** 获取用户Session信息,触发条件 1. session.Bind(Userid) */ Query(Userid string) (data []byte, err error) /** 用户心跳,触发条件 1. 每一次客户端心跳 可以用来延长Session信息过期时间 */ Heartbeat(session Session) } 设置监听器 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { //注意这里一定要用 gate.Gate 而不是 module.BaseModule this.Gate.OnInit(this, app, settings, gate.SetStorageHandler(this), ) } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 22:24:56 "},"data_structure_response.html":{"url":"data_structure_response.html","title":"Response数据结构","keywords":"","body":"概述示例时序图主题(topic)消息体(body)mqant默认封装规则Result类型Error类型自定义返回格式ProtocolMarshal如何省掉无效的编解码流程呢？概述 在Request-Response模式下,网关需要将后端模块返回的数据在返回给客户端即Response,此时需要网关与客户端约定一套数据结构,方便客户端解析 客户端与网关是长连接，因此不同的mqtt包会交叉传递 示例时序图 sequenceDiagram participant 客户端 participant 网关 participant 后端模块 客户端 ->> 网关:Request01(topic=HelloWord/HD_Say/001) 网关 ->> 后端模块:RPC01 客户端 ->> 网关:Request02(topic=HelloWord/HD_Login/002) 网关 ->> 后端模块:RPC02 后端模块 -->> 网关:RPC01 网关 -->> 客户端:Response01(topic=HelloWord/HD_Say/001) 客户端 ->> 网关:Request03(topic=HelloWord/HD_Say/003) 网关 ->> 后端模块:RPC03 后端模块 -->> 网关:RPC03 网关 -->> 客户端:Response03(topic=HelloWord/HD_Say/003) 后端模块 -->> 网关:RPC02 网关 -->> 客户端:Response02(topic=HelloWord/HD_Login/002) 主题(topic) Response时，网关发送给客户端的topic跟Request时完全一致,因此客户端可通过唯一topic确定返回数据是哪个请求的。 消息体(body) mqant默认封装规则 mqant默认封装为json结构体,具体结构如下 { Error string Result interface{} } Result 代表hander函数执行正确时返回的结果 类型 bool int32 int64 long64 float32 float64 []byte string map[string]interface{} Error 代表hander函数执行错误时返回的错误描述 类型 string error 自定义返回格式 mqant默认规则使用json来封装，但实际情况下不同的应用场景可能需要的封装数据格式有所不同,例如有些场景倾向于用protobuf封装。 且默认的封装规则不支持自定义数据类型。 app.SetProtocolMarshal(func(Result interface{},Error string)(module.ProtocolMarshal,string){ //下面可以实现你自己的封装规则(数据结构) r := &resultInfo{ Error: Error, Result: Result, } b,err:= json.Marshal(r) if err == nil { //解析得到[]byte后用NewProtocolMarshal封装为module.ProtocolMarshal return app.NewProtocolMarshal(b),\"\" } else { return nil,err.Error() } }) ProtocolMarshal 如下 mqant默认返回值是这样的 result map[string][string], err string func (m *Login) login(session gate.Session, msg map[string]interface{}) (result map[string][string], err string) { 。。。 return map[string][string]{ \"info\":\"login success\" }, \"\" } rpc通信编码/解密流程: map—>[]byte ——— []byte—>map—>[]byte—> client 最终发送给客户端的是[]byte类型，中间经历一次 []byte—>map—>[]byte 的无用编解码流程 如何省掉无效的编解码流程呢？ 答案: 在后端模块提前编码为[]byte类型，如何实现见以下代码: func (this *Login) login(session gate.Session, msg map[string]interface{}) (result module.ProtocolMarshal, err string) { return this.App.ProtocolMarshal(\"\",\"login success\",\"\") } 实现原理: 返回值用 this.App.ProtocolMarshal 函数封装一遍即可，返回值改为了module.ProtocolMarshal类型 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 22:55:13 "},"custom_gateway_routing.html":{"url":"custom_gateway_routing.html","title":"自定义网关路由","keywords":"","body":"topic uri路由器基于uri协议的路由规则示例如何启用模块创建一个UriRoute结构体实现自定义路由器替换默认的gate路由规则topic uri路由器 mqant gate网关的默认路由规则为 [moduleType@moduleID]/[handler]/[msgid] 但这个规则不太灵活,因此设计了一套基于URI规则的topic路由规则。 基于uri协议的路由规则 ://:@:/;?# 可以充分利用uri公共库 资源划分更加清晰明确 示例 见 IM通信协议示例 如何启用模块 创建一个UriRoute结构体 //注意这里一定要用 gate.Gate 而不是 module.BaseModule this.Route=uriroute.NewURIRoute(this, uriroute.Selector(func(topic string, u *url.URL) (s module.ServerSession, err error) { moduleType:=u.Scheme nodeId:=u.Hostname() //使用自己的 if nodeId==\"modulus\"{ //取模 }else if nodeId==\"cache\"{ //缓存 }else if nodeId==\"random\"{ //随机 }else{ // //指定节点规则就是 module://[user:pass@]nodeId/path //方式1 // moduleType=fmt.Sprintf(\"%v@%v\",moduleType,u.Hostname()) //方式2 return this.GetRouteServer(moduleType,selector.WithFilter(selector.FilterEndpoint(nodeId))) } return this.GetRouteServer(moduleType) }), uriroute.DataParsing(func(topic string, u *url.URL, msg []byte) (bean interface{}, err error) { //根据topic解析msg为指定的结构体 //结构体必须满足RPC的参数传递标准 return }), uriroute.CallTimeOut(3*time.Second), ) 实现自定义路由器 func (this *Gate) OnRoute(session gate.Session, topic string, msg []byte) (bool, interface{}, error) { needreturn := true u, err := url.Parse(topic) if err != nil { return needreturn, nil, errors.Errorf(\"topic is not uri %v\", err.Error()) } if strings.HasPrefix(topic, \"account://modulus/init_by_deviceid\") { //拦截协议 message := map[string]interface{}{} err := json.Unmarshal(msg, &message) if err != nil { return needreturn, \"\", err } r, errstr := this.init_by_deviceid(session, message) if errstr != \"\" { return needreturn, \"\", errors.Errorf(errstr) } return needreturn, r, nil }else { //利用UriRoute将消息转发至后端模块 return this.Route.OnRoute(session, topic, msg) } return needreturn, \"success\", nil } 替换默认的gate路由规则 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { this.Gate.OnInit(this, app, settings, gate.SetRouteHandler(OnRoute), ) } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-29 14:43:45 "},"im_gateway_routing.html":{"url":"im_gateway_routing.html","title":"IM通信协议示例","keywords":"","body":"通信协议http协议mqtt协议mqtt协议的使用mqtt协议简介im模块中mqtt协议的用法uri资源划分客户端如何接受服务端返回消息请求-响应模式客户端请求服务器响应服务器PUSH模式通信协议 http协议 历史消息拉取 群组列表拉取 server-to-server接口调用 mqtt协议 基于tcp,websocket长连接 消息下发 mqtt协议的使用 mqant只用了mqtt 3.1版本的协议,目前主流开发语言都有相应的客户端开发库。 mqant只用到了mqtt的【发布消息】协议，订阅协议未支持 mqtt协议简介 mqtt协议包可以简单的理解为就以下的这两个字段，不管是server-to-client 还是client-to-server -- topic string 可以理解为路由 -- body []byte 消息体,是任意二进制流 im模块中mqtt协议的用法 im模块中topic被限定为标准的URI格式 ://:@:/;?# uri资源划分 scheme http/https 用于客户端http流量代理(httpproxy) client-mqtt->im-server-http->http-server eg. topic: http://www.wanwan.com/pay/one.json body: type HttpRequest struct { Header map[string]string Body string Method string } return: type HttpResponse struct { Header http.Header Body interface{} Err error StatusCode int } local im模块预留私有协议 system im模块预留私有协议 业务模块 scheme 用于指定mqant后端微服务的模块ID hostname 用于指定业务模块节点路由规则 业务模块可能有多个节点 modulus 取模 cache 缓存 random 随机 其他规则 例如节点ID eg. topic1: im://modulus/remove_feeds_member?msg_id=1002 代表访问后端的im模块,按取模的规则选择im模块的一个节点 访问方法 /remove_feeds_member msg_id=1002 用来唯一标识一次请求 body: { \"member\":\"要移除成员userId\", \"feeds\":\"feedsid\" } topic2: im://d8feff3dc8daf472/agree_join_feeds?msg_id=1003 代表访问后端的im模块的d8feff3dc8daf472节点 访问方法 /remove_feeds_member msg_id=1002 用来唯一标识一次请求 body: { \"applicant\":\"申请人userId\", \"feeds\":\"feedsid\" } 客户端如何接受服务端返回消息 请求-响应模式 客户端先发起一次请求,服务器在处理完后返回对应结果 客户端请求 topic: im://modulus/remove_feeds_member?msg_id=1002 body: { \"member\":\"要移除成员userId\", \"feeds\":\"feedsid\" } 服务器响应 请看,服务器响应消息时topic跟客户端请求时完全相同, 因此客户端只要保证topic每一次请求都是唯一的,并且记住它, 那么在服务器响应时就能找到正确的处理代码了 topic: im://modulus/remove_feeds_member?msg_id=1002 body: { \"Trace\":\"94218104768aa033\", \"Error\":\"\", \"Result\":\"success\" } 服务器PUSH模式 当用户A给用户B发消息是,im工具需要主动的通知用户B消息 这种情况一般我们会提前跟服务器约定好这类消息的topic eg. 通知feeds有新消息 topic: impush://modulus/news body: { \"feeds\":\"feeds id\" \"last_seq_id\":int //最新消息的序列号 \"message\":{ \"MsgId\":string //消息唯一ID \"Feeds\":string //消息所属消息组 \"SeqId\":int //消息顺序ID \"MsgType\":string //消息类型 text image 语音：voice 视频：video 小视频：shortvideo 地理位置：location 连接消息：link *\"From\":string //谁发出的 \"Payload\":Object //谁发出的 \"TimeCreate\":int //消息创建时间(发送) } } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-05 23:01:50 "},"gateway_optional_settings.html":{"url":"gateway_optional_settings.html","title":"网关可选设置","keywords":"","body":"最大同时任务数网络读写缓存大小数据包最大长度客户端心跳间隔建连超时时间建立TLS加密通信最大同时任务数 为了防止客户端上次消息太过频繁,影响网关性能,可以设置一个连接的最大同时任务书 默认值为20 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { this.Gate.OnInit(this, app, settings, gate.ConcurrentTasks(5), ) } 如果连接最大任务数超过限制，会报 the work queue is full! 错误，此时你需要关注客户端消息频率以及后端任务响应耗时是否合理 网络读写缓存大小 缓存分为读缓存和写缓存，缓存大小设置需要根据具体业务场景而定，如缓存设置过大对服务器内存消耗会比较多，如设置过小则可能导致读写卡顿，写数据时如缓存已满,则数据包会丢弃。 默认值2048 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { this.Gate.OnInit(this, app, settings, gate.BufSize(1024), ) } 数据包最大长度 为防止解包错误或恶意攻击,导致服务器内存溢出,需要限制每一个数据包的最大长度,超过最大长度限制的连接将被断开 默认值65535 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { this.Gate.OnInit(this, app, settings, gate.MaxPackSize(65536) ) } 客户端心跳间隔 默认值 time.Minute func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { this.Gate.OnInit(this, app, settings, gate.Heartbeat(1*time.Minute) ) } 建连超时时间 为防止连接到网关又为建立mqtt协议的异常连接,我们设置一个超时机制,客户端连接到网关以后需在设置时间内完成mqtt协议建立,否则连接将被断开 默认值 time.Second * 10 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { this.Gate.OnInit(this, app, settings, gate.OverTime(20*time.Second), ) } 建立TLS加密通信 tcp和ws都可以建立安全的加密通信(tls) 默认 不安全通信 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { this.Gate.OnInit(this, app, settings, gate.Tls(true), gate.CertFile(\"xxx.cert\"), gate.KeyFile(\"xxx.key\"), ) } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-06 08:13:07 "},"gateway_connect_monitor.html":{"url":"gateway_connect_monitor.html","title":"连接建立与断连","keywords":"","body":"监听器定义实现示例设置监听器获取连接代理对象(agent)监听器定义 type SessionLearner interface { Connect(a Session) //当连接建立 并且MQTT协议握手成功 DisConnect(a Session) //当连接关闭 或者客户端主动发送MQTT DisConnect命令 } 实现示例 //当连接建立 并且MQTT协议握手成功 func (this *Gate) Connect(session gate.Session) { agent,err:=this.GetGateHandler().GetAgent(session.GetSessionId()) if err!=nil{ } agent.ConnTime() } //当连接关闭 或者客户端主动发送MQTT DisConnect命令 ,这个函数中Session无法再继续后续的设置操作，只能读取部分配置内容了 func (this *Gate) DisConnect(session gate.Session) { } 设置监听器 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { this.Gate.OnInit(this, app, settings, gate.SetSessionLearner(this), ) } 获取连接代理对象(agent) agent,err:=this.GetGateHandler().GetAgent(session.GetSessionId()) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-06 08:24:12 "},"gateway_message_interception.html":{"url":"gateway_message_interception.html","title":"消息拦截","keywords":"","body":"概述上行消息拦截实现自定义路由器替换默认的gate路由规则下行消息拦截概述 有些场景我们需要拦截或监听部分上行或者下行消息。 上行消息拦截 利用自定义路由器实现(RouteHandler) 实现自定义路由器 func (this *Gate) OnRoute(session gate.Session, topic string, msg []byte) (bool, interface{}, error) { needreturn := true u, err := url.Parse(topic) if err != nil { return needreturn, nil, errors.Errorf(\"topic is not uri %v\", err.Error()) } if strings.HasPrefix(topic, \"account://modulus/init_by_deviceid\") { //拦截协议 message := map[string]interface{}{} err := json.Unmarshal(msg, &message) if err != nil { return needreturn, \"\", err } r, errstr := this.init_by_deviceid(session, message) if errstr != \"\" { return needreturn, \"\", errors.Errorf(errstr) } return needreturn, r, nil }else { //利用UriRoute将消息转发至后端模块,也可以实现自己的Route规则 return this.Route.OnRoute(session, topic, msg) } return needreturn, \"success\", nil } 替换默认的gate路由规则 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { this.Gate.OnInit(this, app, settings, gate.SetRouteHandler(OnRoute), ) } 下行消息拦截 可以通过SendMessageHook替换下行消息体(Body),也可以直接拦截不允许发送 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { this.Gate.OnInit(this, app, settings, gate.SetSendMessageHook(func(session gate.Session, topic string, msg []byte) (bytes []byte, e error) { return nil, errors.New(\"本协议不允许发送给客户端\") }), ) } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-06 08:38:32 "},"gateway_local_operation.html":{"url":"gateway_local_operation.html","title":"网关本地操作","keywords":"","body":"概述获取GateHandler获取网关当前连接数获取连接agent给指定连接发送消息群发消息概述 如果业务需要在网关模块操作本网关的功能，可以使用GateHandler，这样可以避免RPC操作 获取GateHandler this.Gate.GetGateHandler() 获取网关当前连接数 this.Gate.GetGateHandler().GetAgentNum() 获取连接agent this.Gate.GetGateHandler().GetAgent(Sessionid string) (Agent, error) 给指定连接发送消息 this.Gate.GetGateHandler().Send(span log.TraceSpan, Sessionid string, topic string, body []byte) (result interface{}, err string 群发消息 this.Gate.GetGateHandler().BroadCast(span log.TraceSpan, topic string, body []byte) (int64, string) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-06 08:55:29 "},"custom_agent.html":{"url":"custom_agent.html","title":"自定义通信协议","keywords":"","body":"概述agent定义实现自定义的agent替换默认agent生成器概述 如果项目无法使用mqtt协议，需要自定义通信协议,可以使用下面的方法，如果替换默认的agent,以上长连接网关文章的功能都将不可用，可以自己实现 agent定义 type Agent interface { OnInit(gate Gate, conn network.Conn) error WriteMsg(topic string, body []byte) error Close() Run() (err error) OnClose() error Destroy() ConnTime() time.Time RevNum() int64 SendNum() int64 IsClosed() bool GetSession() Session } 实现自定义的agent CustomAgent.go package mgate import ( \"bufio\" \"github.com/liangdas/mqant/gate\" \"github.com/liangdas/mqant/log\" \"github.com/liangdas/mqant/module\" \"github.com/liangdas/mqant/network\" \"time\" ) func NewCustomAgent(module module.RPCModule) *CustomAgent { a := &CustomAgent{ module: module, } return a } type CustomAgent struct { gate.Agent module module.RPCModule session gate.Session conn network.Conn r *bufio.Reader w *bufio.Writer gate gate.Gate rev_num int64 send_num int64 last_storage_heartbeat_data_time time.Duration //上一次发送存储心跳时间 isclose bool } func (this *CustomAgent) OnInit(gate gate.Gate, conn network.Conn) error { log.Info(\"CustomAgent\", \"OnInit\") this.conn = conn this.gate = gate this.r = bufio.NewReader(conn) this.w = bufio.NewWriter(conn) this.isclose = false this.rev_num = 0 this.send_num = 0 return nil } /** 给客户端发送消息 */ func (this *CustomAgent) WriteMsg(topic string, body []byte) error { this.send_num++ //粘包完成后调下面的语句发送数据 //this.w.Write() return nil } func (this *CustomAgent) Run() (err error) { log.Info(\"CustomAgent\", \"开始读数据了\") this.session, err = this.gate.NewSessionByMap(map[string]interface{}{ \"Sessionid\": \"生成一个随机数\", \"Network\": this.conn.RemoteAddr().Network(), \"IP\": this.conn.RemoteAddr().String(), \"Serverid\": this.module.GetServerId(), \"Settings\": make(map[string]string), }) //这里可以循环读取客户端的数据 //这个函数返回后连接就会被关闭 return nil } /** 接收到一个数据包 */ func (this *CustomAgent) OnRecover(topic string, msg []byte) { //通过解析的数据得到 moduleType := \"\" _func := \"\" //如果要对这个请求进行分布式跟踪调试,就执行下面这行语句 //a.session.CreateRootSpan(\"gate\") //然后请求后端模块，第一个参数为session result, e := this.module.RpcInvoke(moduleType, _func, this.session, msg) log.Info(\"result\", result) log.Info(\"error\", e) //回复客户端 this.WriteMsg(topic, []byte(\"请求成功了谢谢\")) this.heartbeat() } func (this *CustomAgent) heartbeat() { //自定义网关需要你自己设计心跳协议 if this.GetSession().GetUserId() != \"\" { //这个链接已经绑定Userid interval := int64(this.last_storage_heartbeat_data_time) + int64(this.gate.Options().Heartbeat) //单位纳秒 if interval 替换默认agent生成器 func (this *Gate) OnInit(app module.App, settings *conf.ModuleSettings) { //注意这里一定要用 gate.Gate 而不是 module.BaseModule this.Gate.OnInit(this, app, settings, gate.Heartbeat(time.Second*10)) this.Gate.SetCreateAgent(func() gate.Agent { agent:= NewCustomAgent(this) return agent }) } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-06 08:56:02 "},"httpgate_introduce.html":{"url":"httpgate_introduce.html","title":"网关介绍","keywords":"","body":"概述使用http网关代码组织结构初始化网关监听创建网关http.Handler网关默认路径规则举例实现后端http协议编写handler注册handler(方案一)注册handler(方案二)设置handler监听器运行访问结果用gin替代默认http框架概述 mqant实现了一个比较简单的http网关,可以用来代理前端发起的http api请求 使用http网关 mqant提供了一个创建代理网关的http.Handler 代码组织结构 首先我们重新组织了一下代码目录结构，新增了一个httpgateway目录用来存放http网关模块代码以及一个后端http handler 工程目录 |-bin |-conf |-server.conf |-httpgateway |-module.go |-main.go 初始化网关监听 var Module = func() module.Module { this := new(httpgate) return this } type httpgate struct { basemodule.BaseModule } func (self *httpgate) GetType() string { //很关键,需要与配置文件中的Module配置对应 return \"httpgate\" } func (self *httpgate) Version() string { //可以在监控时了解代码版本 return \"1.0.0\" } func (self *httpgate) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings) self.SetListener(self) } func (self *httpgate) startHttpServer() *http.Server { srv := &http.Server{ Addr: \":8090\", Handler:httpgateway.NewHandler(self.App), } //http.Handle(\"/\", httpgateway.NewHandler(self.App)) go func() { if err := srv.ListenAndServe(); err != nil { // cannot panic, because this probably is an intentional close log.Info(\"Httpserver: ListenAndServe() error: %s\", err) } }() // returning reference so caller can call Shutdown() return srv } func (self *httpgate) Run(closeSig chan bool) { log.Info(\"httpgate: starting HTTP server :8090\") srv := self.startHttpServer() 创建网关http.Handler httpgateway.NewHandler(self.App) 网关默认路径规则 网关默认路由规则是从URL.Path的第一个段取出moduleType /[moduleType]/path 举例 http://127.0.0.1:8090/httpgate/topic moduleType httpgate hander /httpgate/topic 实现后端http协议 网关转发RPC的handler定义为 func (self *httpgate) httpgateway(request *go_api.Request) (*go_api.Response,error) {} 编写handler func (self *httpgate) httpgateway(request *go_api.Request) (*go_api.Response,error) { mux := http.NewServeMux() mux.HandleFunc(\"/httpgate/topic\", func(writer http.ResponseWriter, request *http.Request) { writer.Write([]byte(`hello world`)) }) req, err := http.NewRequest(request.Method, request.Url, strings.NewReader(request.Body)) if err != nil { return nil,err } for _,v:=range request.Header{ req.Header.Set(v.Key, strings.Join(v.Values,\",\")) } rr := httptest.NewRecorder() mux.ServeHTTP(rr, req) resp := &go_api.Response{ StatusCode: int32(rr.Code), Body: rr.Body.String(), Header: make(map[string]*go_api.Pair), } for key, vals := range rr.Header() { header, ok := resp.Header[key] if !ok { header = &go_api.Pair{ Key: key, } resp.Header[key] = header } header.Values = vals } return resp,nil } 注册handler(方案一) self.GetServer().RegisterGO(\"/httpgate/topic\",self.httpgateway) 注册handler(方案二) 方案一比较固化,跟mqant框架绑定,我们希望能够在编写http函数是能利用golang已存在的web库,又能跟mqant网关结合 利用mqrpc.RPCListener监听未实现的handler，然后将请求通过httptest路由web框架中 当RPC未找到已注册的handler时会调用 func NoFoundFunction(fn string)(*mqrpc.FunctionInfo,error) func (self *httpgate) NoFoundFunction(fn string)(*mqrpc.FunctionInfo,error){ return &mqrpc.FunctionInfo{ Function:reflect.ValueOf(self.httpgateway), Goroutine:true, },nil } func (self *httpgate) BeforeHandle(fn string, callInfo *mqrpc.CallInfo) error{ return nil } func (self *httpgate) OnTimeOut(fn string, Expired int64){ } func (self *httpgate) OnError(fn string, callInfo *mqrpc.CallInfo, err error){} func (self *httpgate) OnComplete(fn string, callInfo *mqrpc.CallInfo, result *rpcpb.ResultInfo, exec_time int64){} 设置handler监听器 func (self *httpgate) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings) self.SetListener(self) } 运行 2020-05-06T16:09:19.98671+08:00 [-] [-] [development] [I] [rpc_server.go:142] Registering node: httpgate@4bfaf93bd31c512a 2020-05-06T16:09:19.988701+08:00 [-] [-] [development] [I] [ws_server_x.go:131] WS Listen ::3653 2020-05-06T16:09:19.989593+08:00 [-] [-] [development] [I] [tcp_server.go:39] TCP Listen ::3563 2020-05-06T16:09:19.995531+08:00 [-] [-] [development] [I] [module.go:62] httpgate: starting HTTP server :8090 访问 http://127.0.0.1:8090/httpgate/topic 结果 hello world 用gin替代默认http框架 如上的httpgateway函数中，网络框架可以用gin,echo,beego等其他web框架替代 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-27 19:24:18 "},"custom_httpgate_routing.html":{"url":"custom_httpgate_routing.html","title":"网关自定义路由","keywords":"","body":"概述网关默认路径规则举例编写自定义路由规则器ServiceServerSession概述 网关默认路由规则可能不满足业务场景的路由需求,可以自定义 网关默认路径规则 网关默认路由规则是从URL.Path的第一个段取出moduleType /[moduleType]/path 举例 http://127.0.0.1:8090/httpgate/topic moduleType httpgate hander /httpgate/topic 编写自定义路由规则器 srv := &http.Server{ Addr: \":8090\", Handler:httpgateway.NewHandler(self.App, httpgateway.SetRoute(func(app module.App, r *http.Request) (service *httpgateway.Service, e error) { return nil, nil })), } Service type Service struct { // hander Hander string // node SrvSession module.ServerSession } ServerSession 可以通过app.GetRouteServer函数获取 session,err:= app.GetRouteServer Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-06 16:41:48 "},"room_module_introduce.html":{"url":"room_module_introduce.html","title":"模块介绍","keywords":"","body":"概述场景举例房间模块解决的问题解决方案房间模块生命周期概述 在游戏开发中很多场景都会用到房间模型，例如棋牌的桌子匹配、聊天室等等。除了游戏以为很多业务场景都可以利用房间模式来解决。 场景举例 棋牌房间分配 将在线玩家匹配到同一个房间牌桌上进行游戏 游戏副本 游戏副本也可以设计为一个一个的房间 在线聊天室(直播) 为每一个主播创建一个房间,用户要跟主播互动就进入到对应的房间即可 房间模块解决的问题 [!TIP|style:flat|label:解决多线程资源资源抢占的问题|iconVisibility:hidden] 通常多个客户端用户请求时序是不可控的,如果不做管控当两条消息在同一个时间(间隔可能小于10ms)到达服务器， 那么就会出现多线程并行抢占资源的问题，导致游戏逻辑混乱。 解决方案 引入消息队列,将请求消息串行化。解决了资源锁的问题,同时在开发过程中完全不需要考虑消息并发的问题,所有指令都是串行执行的。 房间模块生命周期 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-17 18:22:48 "},"room_module_composition.html":{"url":"room_module_composition.html","title":"模块组成","keywords":"","body":"概述组织结构依赖模块引用开发测试概述 房间模块由一下几个功能块组成 组织结构 房间 通常一个进程就一个房间 桌子 桌子在房间中,一个房间可以包含多个桌子,桌子是我们房间具体实现的主体,绝大部分功能都在桌子内实现 room进程一 |- table-001 |- table-002 |- table-003 |- ... 依赖模块 go.mod github.com/liangdas/mqant-modules v1.3.1 引用 import ( \"github.com/liangdas/mqant-modules/room\" ) 开发 下面的章节将讲解房间模块的开发流程，但强烈建议你先阅读一下 mqant-example中的示例源码,以有一个整体的了解 房间demo源码 测试 func main() { task := task.LoopTask{ C: 1, //并发数 } manager := table_test.NewManager(task) //房间模型的demo //manager := test_task.NewManager(task) //gate demo fmt.Println(\"开始压测请等待\") task.Run(manager) c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) Connect... OnConnectHandler tabletest/HD_room_say/2 {\"Trace\":\"0475a842d84c95ec\",\"Error\":\"\",\"Result\":\"success\"} me is 81 /room/join =》 welcome to 81 me is 81 /room/say =》 say hi from 81 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-11-12 19:43:06 "},"room_management.html":{"url":"room_management.html","title":"房间管理","keywords":"","body":"概述创建房间结构体创建桌子NewTableFunc获取桌子示例代码handler注册跟客户端约定的数据结构概述 房间管理比较简单，通常我们希望一个进程中可创建多个房间,这样才能最大化利用服务器资源,因此我们将房间模块划分为room、table两个级别，room用来管理table 创建房间结构体 func (self *tabletest) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings, server.RegisterInterval(15*time.Second), server.RegisterTTL(30*time.Second), ) self.room = room.NewRoom(self) } 创建桌子 CreateById(module module.RPCModule, tableId string, newTablefunc NewTableFunc) (BaseTable, error) //调用代码 table, err = self.room.CreateById(self, table_id, self.NewTable) CreateById table_id 桌子唯一ID,作为这个房间内桌子的唯一标识 NewTableFunc 创建桌子的具体方法,room负责创建桌子的具体逻辑,它仅维护桌子在room下的对应 NewTableFunc type NewTableFunc func(module module.RPCModule, tableId string) (BaseTable, error) 由开发者自己实现桌子的具体创建逻辑,如下 func (self *tabletest) NewTable(module module.RPCModule, tableId string) (room.BaseTable, error) { table := NewTable( module, room.TableId(tableId), room.DestroyCallbacks(func(table room.BaseTable) error { log.Info(\"回收了房间: %v\", table.TableId()) _ = self.room.DestroyTable(table.TableId()) return nil }), ) return table, nil } 获取桌子 GetTable(tableId string) BaseTable //代码 table := self.room.GetTable(table_id) 如若没有创建过table_id的桌子将返回nil 示例代码 [!TIP|style:flat|label:简单聊天室|iconVisibility:hidden] 一个简单的聊天室功能,table_id由客户端指定,当桌子不存在是则创建一个新的。 然后将客户端消息写入桌子的消息队列中 func (self *tabletest) gatesay(session gate.Session, msg map[string]interface{}) (r string, err error) { table_id := msg[\"table_id\"].(string) action := msg[\"action\"].(string) table := self.room.GetTable(table_id) if table == nil { table, err = self.room.CreateById(self, table_id, self.NewTable) if err != nil { return \"\", err } } erro := table.PutQueue(action, session, msg) if erro != nil { return \"\", erro } return \"success\", nil } handler注册 func (self *tabletest) OnInit(app module.App, settings *conf.ModuleSettings) { self.BaseModule.OnInit(self, app, settings, server.RegisterInterval(15*time.Second), server.RegisterTTL(30*time.Second), ) self.room = room.NewRoom(self) self.GetServer().RegisterGO(\"HD_room_say\", self.gatesay) } 跟客户端约定的数据结构 { \"table_id\":\"{table_id}\", \"action\":\"/room/say\", \"name\":\"{name}\" } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-17 17:10:46 "},"table_function_development.html":{"url":"table_function_development.html","title":"桌子开发","keywords":"","body":"概述第一步 桌子结构体第二步 必须要继承的函数可选继承函数第三步 初始化QTable第四步 实现handlerhandler实现handler注册跟客户端约定的数据结构消息传递概述 上一章讲解了房间管理的功能,本章将讲解桌子的具体开发 第一步 桌子结构体 [!TIP|style:flat|label:桌子的定义|iconVisibility:hidden] mqant将桌子的核心功能封装到了QTable中,开发者主要继承QTable完成业务功能的开发 type MyTable struct { room.QTable module module.RPCModule players map[string]room.BasePlayer } 第二步 必须要继承的函数 [!TIP|style:flat|label:继承函数|iconVisibility:hidden] QTable有两个结构体需要开发者提供,以实现其内部的功能 GetModule() 返回module.RPCModule GetSeats() 返回一个桌子内座位(用户)的map GetSeats() map[string]room.BasePlayer 可选继承函数 当桌子初始化后会调用OnCreate(),可以在这做一些业务初始化（加载数据）等操作,但一定要调用QTable.OnCreate() func (this *MyTable) OnCreate() { //可以加载数据 log.Info(\"MyTable OnCreate\") //一定要调用QTable.OnCreate() this.QTable.OnCreate() } 第三步 初始化QTable [!TIP|style:flat|label:初始化参数|iconVisibility:hidden] QTable有许多设置参数都可以在初始化时设置,后续章节会详细阐述 OnInit(subtable SubTable, opts ...Option) error this := &MyTable{ module: module, players: map[string]room.BasePlayer{}, } this.OnInit(this, opts...) 第四步 实现handler [!TIP|style:flat|label:桌子hander|iconVisibility:hidden] 房间模块跟mqant的模块工作方式类似,也支持路由+handler的方式处理消息 handler实现 加入房间的handler 首先将session跟room.BasePlayer绑定 将room.BasePlayer注册桌子座位管理map中 最后广播了一条消息给所有已加入房间的客户端 func (this *MyTable) doJoin(session gate.Session, msg map[string]interface{}) (err error) { player := &room.BasePlayerImp{} player.Bind(session) player.OnRequest(session) this.players[session.GetSessionId()] = player _ = this.NotifyCallBackMsg(\"/room/join\", []byte(fmt.Sprintf(\"welcome to %v\", msg[\"name\"]))) return nil } handler注册 路由是 /room/join 处理函数为 doJoin func NewTable(module module.RPCModule, opts ...room.Option) *MyTable { this := &MyTable{ module: module, players: map[string]room.BasePlayer{}, } this.OnInit(this, opts...) this.Register(\"/room/say\", this.doSay) this.Register(\"/room/join\", this.doJoin) return this } 跟客户端约定的数据结构 { \"table_id\":\"{table_id}\", \"action\":\"/room/say\", \"name\":\"{name}\" } 消息传递 基于本教程示例,简单讲解消息传递流程 客户端发送消息给mqant房间模块指定handler(HD_room_say) HD_room_say通过消息中的table_id值获取(创建)桌子 通过table.PutQueue(action, session, msg)将消息写入桌子接收队列中 待桌子下一帧执行时从队列中取出消息 通过action找到桌子handler 调用桌子handler执行函数 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-17 17:58:52 "},"room_BasePlayer.html":{"url":"room_BasePlayer.html","title":"BasePlayer","keywords":"","body":"概述定义绑定用户更新用户状态概述 room.BasePlayer表示在桌子中的座位它有以下几个功能和特性 管理了座位跟实际用户的绑定关系 这个座位可能有用户,也可能没有用户 记录了桌子与用户的最后通信时间 对已绑定用户的情况,如果用户断线或异常退出,需要有一种超时机制来检查 定义 type BasePlayer interface { IsBind() bool Bind(session gate.Session) BasePlayer /** 玩家主动发请求时触发 */ OnRequest(session gate.Session) /** 服务器主动发送消息给玩家时触发 */ OnResponse(session gate.Session) /* 服务器跟玩家最后一次成功通信时间 */ GetLastReqResDate() int64 Body() interface{} SetBody(body interface{}) Session() gate.Session Type() string } 绑定用户 当用户请求到桌子是,在通过安全验证后可以将用户的session绑定的对应的BasePlayer中 func (this *MyTable) doJoin(session gate.Session, msg map[string]interface{}) (err error) { player := &room.BasePlayerImp{} player.Bind(session) 。。。 } 更新用户状态 用户每次给桌子发送请求,都应该更新BasePlayer状态 可能session状态改变 断连重连上来的网关已换 有更加新的session.settings数据 更新用户跟桌子最后通信时间 桌子会根据最后通信时间判断用户是否已断开跟桌子的连接（心跳） player.OnRequest函数会帮你做上面的两件事,但你必须在每一个用户给桌子发送的handler消息中主动调用 func (this *MyTable) doSay(session gate.Session, msg map[string]interface{}) (err error) { player := this.FindPlayer(session) if player == nil { return errors.New(\"no join\") } player.OnRequest(session) ... } Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-17 17:18:35 "},"room_module_initialize_settings.html":{"url":"room_module_initialize_settings.html","title":"初始化设置说明","keywords":"","body":"概述设置函数房间生命周期管理超时时间房间回收回调Update设置运行周期（帧）时间消息队列容量管理设置接收消息的队列容量设置发送消息的队列容量异常处理函数当桌子handler未找到时handler返回错误信息handler执行崩溃概述 room.QTable有许多初始化设置项,可以用来控制以下的几大功能 房间生命周期管理 超时时间 房间回收回调 每帧更新函数Update 运行周期（帧） 多少间隔处理一次消息,一般根据业务场景而定 消息队列容量管理 消息接收队列容量管理 消息发送队列容量管理 异常处理函数 handler未找到 handler返回错误信息 handler执行崩溃 设置函数 QTable.OnInit(subtable SubTable, opts ...room.Option) error 房间生命周期管理 超时时间 [!TIP|style:flat|label:超时时间|iconVisibility:hidden] 当桌子超过指定的时间未与客户端（指所有客户端）建立通信(上行或下行通信),则认为桌子已超时,会自动回收 如timeout=0则自动检查功能关闭(需要你手动控制桌子的生命周期) 默认timeout=60 room.TimeOut(60) 房间回收回调 当房间被回收是我们希望能够知道，方便我们做一些资源回收工作,例如房间信息存档，将房间从room移除等等 room.DestroyCallbacks(func(table room.BaseTable) error { log.Info(\"回收了房间: %v\", table.TableId()) _ = self.room.DestroyTable(table.TableId()) return nil }), Update 桌子每周期(帧)都会执行,如果想再每周期都做一些工作,可以设置update函数,如果不设置则只执行handler room.Update(this.Update) /** 每帧都会调用 */ func (this *MyTable) Update(ds time.Duration) { //ds 上一帧跟当前帧的间隔时间 } 设置运行周期（帧）时间 [!TIP|style:flat|label:帧时间|iconVisibility:hidden] room.QTable使用mqant内置的时间轮,每一个周期执行完后就会注册下一个执行周期的时间。 如果执行期间出现崩溃则不会再注册,桌子会被强制Finish()回收。 默认值为100ms room.RunInterval(50*time.Millisecond) 消息队列容量管理 如果每一个周期超过设置大小的消息数将插入失败 设置接收消息的队列容量 容量是设置大小的双倍,因为会创建两个消息队列 默认值为256 room.Capaciity(256) 设置发送消息的队列容量 容量是设置一样大小 默认值为256 room.SendMsgCapaciity(256) 异常处理函数 当桌子handler未找到时 基于它你可以实现一些特殊的业务逻辑 room.NoFound(func(msg *room.QueueMsg) (value reflect.Value, e error) { //return reflect.ValueOf(this.doSay), nil return reflect.Zero(reflect.ValueOf(\"\").Type()), errors.New(\"no found handler\") }) handler返回错误信息 room.SetErrorHandle(func(msg *room.QueueMsg, err error) { log.Error(\"Error %v Error: %v\", msg.Func, err.Error()) }) 如下的情况就会调用ErrorHandle func (this *MyTable) doJoin(session gate.Session, msg map[string]interface{}) (err error) { return errors.New(\"逻辑异常了\") } handler执行崩溃 当handler出现未处理的异常时,可以通过RecoverHandle监控到 room.SetRecoverHandle(func(msg *room.QueueMsg, err error) { log.Error(\"Recover %v Error: %v\", msg.Func, err.Error()) }) Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-17 17:53:26 "},"room_send_message.html":{"url":"room_send_message.html","title":"用户管理","keywords":"","body":"概述给多个玩家发送消息给桌子内所有玩家广播消息不关注结果的发送消息通过session查找BasePlayer概述 给玩家发送消息都是通过session.Send实现，但在room.QTable做了一下封装,能够更方便使用 [!TIP|style:flat|label:注意事项|iconVisibility:hidden] 通过room.QTable函数发消息跟session.Send区别在于，room.QTable函数会先将要发送的消息都存放到消息队列中 待本周期执行完以后再统一发送给客户端,发送之前会合并网关,如多个用户在同一个网关且发送的消息相同则只会进行一次RPC操作 给多个玩家发送消息 SendCallBackMsg(players []string, topic string, body []byte) error 其中players是session().GetSessionId() 列表 给桌子内所有玩家广播消息 NotifyCallBackMsg(topic string, body []byte) error 不关注结果的发送消息 SendCallBackMsgNR(players []string, topic string, body []byte) error NotifyCallBackMsgNR(topic string, body []byte) error 通过session查找BasePlayer [!TIP|style:flat|label:注意事项|iconVisibility:hidden] 对于游客用户使用session.GetSessionId()查找,对于登陆用户使用session().GetUserId() 这样的做法在于如果登陆用户断线重连网关切换了,通过session().GetUserId()依然可以找到BasePlayer FindPlayer(session gate.Session) BasePlayer Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-17 18:14:09 "},"plan.html":{"url":"plan.html","title":"后续计划","keywords":"","body":"后续计划开源项目后续计划 以上章节阐述完了mqant所有的核心功能,后续会继续扩充文档规模,主要从实际应用场景入手介绍mqant的用法和方案 房间模型 数据压缩 状态同步 。。。 开源项目 双人俄罗斯方块 Copyright © 梁大帅 2020 all right reserved，powered by Gitbook该文件修订时间： 2021-02-17 12:44:26 "}}